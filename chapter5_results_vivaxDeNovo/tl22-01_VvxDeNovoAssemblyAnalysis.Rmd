---
title: "tl22-01_VivaxPirsInTheDeNovoAssemblies"
output: 
  html_document:
    theme: cosmo
    code_download: true
    toc: true
    number_sections: true
    toc_float:
      collapsed: false
      smooth_scroll: true
params:
  blast_output_file: '/camp/lab/langhornej/working/HPC/littlet/tl22-01_vivaxDeNovo/blast/scspades/SRX697844_SRR1571714/SRX697844_SRR1571714_blastn.outfmt6'
---

# Intro

This script is looks at the BLAST results of a Trinity _de novo_ assembled transcriptome. 

# What this report shows:

*The level of counts / TPM of pirs that are detected by the Trinity de novo assembled transcriptome.
**e.g. What is the minimum expressed gene detected / What is the maximally expressed gene not detected.

# To-do:
*Check how they BLAST to the rest of the transcriptome, do pir de novo transcripts also BLAST to non-pir transcripts?
*Select the most informative data and poo-poo the rest.
*Save useful files made by this script as csv.

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = FALSE, 
                      results = TRUE, 
                      message = FALSE, 
                      warning = FALSE)
options(scipen = 999) # Means that numbers are displayed normally not as 1e6 (1000000)

#Possible files for blast_output_file:
# '/camp/lab/langhornej/working/HPC/littlet/tl22-01_vivaxDeNovo/blast/scspades/SRX697844_SRR1571714/SRX697844_SRR1571714_blastn.outfmt6'
```

```{r loading_packages, include = FALSE, message = FALSE}
# Load the required packages
library('readr')
library('dplyr', 
        lib.loc = "/camp/home/littlet/R/x86_64-pc-linux-gnu-library/4.0")
library('stringr')
library('purrr')
library('IRanges')
library('kableExtra')
library('plotly')
```

```{r function_ordering}
ordering <- function(to_order, order_vector, fromLast = TRUE){
  order = unlist(sapply(order_vector, 
                        function(x){unique(str_subset(to_order, 
                                                      pattern = paste(x)))}))
  order_missing = unique(to_order[!to_order %in% order])
  unique(c(order, order_missing), fromLast = fromLast)
}
```

```{r function_plotRanges}
#' Plot genomic ranges from the IRanges object or GRanges object.
# from https://rdrr.io/github/JokingHero/rxtras/src/R/plot_wrappers.R

plotRanges <- function(x, xlim = x, main = deparse(substitute(x)),  col = "black", sep = 0.5, ...){
  if (!requireNamespace("IRanges", quietly = TRUE)) {
    stop("IRanges needed for this function to work. Please install it.",
         call. = FALSE)
  }
  height <- 1
  if (is(xlim, "Ranges"))
      xlim <- c(min(start(xlim)), max(end(xlim)))
  bins <- disjointBins(IRanges(start(x), end(x) + 1))
  plot.new()
  plot.window(xlim, c(0, max(bins) * (height + sep)))
  ybottom <- bins * (sep + height) - height
  rect(start(x) - 0.5, ybottom, end(x) + 0.5, ybottom + height, col = col, ...)
  title(main)
  axis(1)
}
```

```{r load_data}
pir.info <- read.csv('PlasmoDBv56_VvxPirs_P01_Sal1.csv', 
                     header = TRUE)
```

```{r read_blast_results}
# list.files('../blast', pattern = 'outfmt')

#Set a filter for bp length to assume is a valid match
filter_nident <- 100

outfmt6_headers <- 
  'qseqid sseqid pident length mismatch gapopen qstart qend sstart send evalue bitscore qcovs qcovhsp slen nident' %>% 
  strsplit(split = ' ') %>% 
  unlist

blast <- read.table(params$blast_output_file,
                    col.names = outfmt6_headers) %>% 
  mutate(
         sseqid = unlist(
           lapply(
             str_extract_all(sseqid, 
                             pattern = '.+(?=\\.1)'), 
             paste, 
             collapse = '_')
         ),
         scovhsp = round( (nident/slen * 100), digits = 2),
         scovs = round(((abs(send - sstart) + 1)/slen *100), digits = 2),
         evalue = format(evalue, scientific = TRUE)
  ) %>% 
  #Filter for the pir genes.
  filter(nident > filter_nident,
         sseqid %in% pir.info$Gene.ID) %>%
  group_by(qseqid) %>% 
  mutate(num_genes_match = n_distinct(sseqid))

# Filter for the top hits for each de novo transcript by e-value.

blast_top <- group_by(blast, qseqid) %>% 
  slice_min(evalue, n = 1)

#Filter for the de novo transcripts which only match a single known pir.
# Also removing idents below 100 because these are probably poor matches.

blast_uniq <- filter(blast, num_genes_match == 1)

#sanity test
# all(blast$scovs >= blast$scovhsp)
```

Filtering matches by a minimum of `r filter_nident`bp to be a valid match.

# Number of hits for each de novo transcript with a BLAST hit.

Are there many de novo transcripts which match multiple different known transcripts? Are most of them unique?

```{r number_of_hits_per_deNovoTranscript}
blast %>% 
  group_by(qseqid) %>% 
  summarise(num = n_distinct(sseqid)) %>% 
  .$num %>% 
  hist(main = 'Histogram of BLAST hits per de novo transcript (50 max)',
       breaks = 50)
```

#Genes with the most number of uniquely mapping de novo transcripts.

```{r number_of_uniq_transcripts_per_gene}
blast %>% 
  filter(num_genes_match== 1) %>% 
  group_by(sseqid) %>% 
  summarise(num_of_uniq_deNovoTranscripts = n_distinct(qseqid),
            max_id = max(pident),
            min_id = min(pident),
            max_nident = max(nident),
            min_nident = min(nident),
            max_gap = max(gapopen),
            min_gap = min(gapopen),
            max_qcovh = max(qcovhsp),
            min_qcovh = min(qcovhsp),
            max_scovh = max(scovhsp),
            min_scovh = min(scovhsp)) %>% 
  arrange(desc(num_of_uniq_deNovoTranscripts)) %>% 
  kbl() %>% kable_styling() %>% scroll_box(width = "100%", height = "400px")
```

# Coverage of the subject (known transcripts) and query (assembled de novo transcripts) sequences. 

Using only the de novo transcripts that uniquely match one known pir transcript.

For our purposes the subject coverage is probably most important.

```{r scov_v_qcov}
fig <- plot_ly(
  blast_uniq,
  x = ~qcovhsp,
  y = ~scovhsp,
  text = ~paste(sseqid)
) %>% 
  layout(xaxis = list(title = "De novo transcript coverage"),
         yaxis = list(title = "Known transcript coverage"))
fig
```

Number of unique genes found by BLAST: `r unique(blast$sseqid) %>% length`.

# Known transcripts with >95% coverage from one de novo transcript.

How many of the known transcripts are covered >=95% by de novo transcripts?

num_match_all and num_match_95 show how many other known transcripts these de novo transcripts match in total or >=95% respectively.

```{r transcripts_covering_most_of_known_transcripts}
transcripts_covered_by_denovo <- blast %>% 
  group_by(qseqid) %>%
  mutate(num_match_all = n_distinct(sseqid)) %>%
  group_by(sseqid) %>% 
  filter(scovhsp >= 95) %>% 
  group_by(qseqid) %>%
  mutate(num_match_95 = n_distinct(sseqid)) %>% 
  arrange(sseqid)
transcripts_covered_by_denovo %>% 
  select(-qstart,-qend,-sstart,-send,-evalue,-bitscore,-qcovs,-slen,-sseqid,-nident,-scovs) %>% 
  kbl() %>% kable_styling() %>% scroll_box(width = "100%", height = "300px")
```

Showing the BLAST alignments of these >=95% coverage de novo transcripts in a graph, and all the matches they have. 
The "n =" number after the transcript name shows how many other BLAST hits the de novo transcript had in total.
Size of each point shows the length of the alignment.

```{r transcripts_covering_most_of_known_transcripts_graph}
blast %>% 
  filter(qseqid %in% unique(transcripts_covered_by_denovo$qseqid)) %>%
  group_by(qseqid) %>%
  mutate(num_match_all = n_distinct(sseqid)) %>% 
  mutate(qseqid = paste0(qseqid, '; n = ', num_match_all),
         over95 = ifelse(scovhsp >= 95, 
                         '>=95% coverage', 
                         '<95% coverage')) %>% 
  plot_ly(x = ~qcovhsp,
          y = ~scovhsp,
          text = ~paste(sseqid, '\n', 
                        length, 'bp', '\n',
                        scovhsp, '% coverage of known'),
          color = ~qseqid,
          size = ~length,
          symbol = ~over95,
          symbols = c('triangle-up', 'circle'),
          sizes = c(2,100),
          legendgroup = ~qseqid) %>% 
  layout(xaxis = list(title = "De novo transcript coverage"),
         yaxis = list(title = "Known transcript coverage"))
```

Alignments with >=95% known coverage but <50% de novo transcript coverage. 

```{r low_qcovhsp}
transcripts_covered_by_denovo %>% 
  filter(qcovhsp < 50) %>% 
  kbl() %>% kable_styling() %>% scroll_box(width = "100%", height = "300px")
```

# Transcripts matched by percentage coverage.

```{r transcript_coverage_by_percentage}

transcripts_covered_by_denovo_diffcov <- lapply(seq(0,100,by = 5),
                                                function(covrg) {
                                                  blast %>% 
                                                    group_by(sseqid) %>% 
                                                    filter(scovhsp >= covrg) %>%
                                                    .$sseqid %>% unique %>% length
                                                })
names(transcripts_covered_by_denovo_diffcov) <- seq(0,100,by = 5)
plot(y = unlist(transcripts_covered_by_denovo_diffcov), 
     x = seq(0,100,by = 5),
     ylim = c(0,nrow(pir.info)),
     main = 'For all de novo transcripts',
     ylab = 'Number of known transcripts covered',
     xlab = 'Percentage of coverage by individual transcripts',
     yaxt = 'none')
axis(2, at = seq(0,nrow(pir.info),by = 100))
# abline(a = 25, b = 0)
                                                    
```

# Important instant details:

Filtered matches by a minimum of `r filter_nident`bp to be a valid match.

There are `r length(unique(transcripts_covered_by_denovo$sseqid))` known transcripts covered by >=95% of at least one individual _de novo_ transcript. There is a mean of `r mean(transcripts_covered_by_denovo$mismatch)` mismatches and `r mean(transcripts_covered_by_denovo$gapopen)` gaps and a median of `r median(transcripts_covered_by_denovo$mismatch)` mismatches and `r median(transcripts_covered_by_denovo$gapopen)` gaps in these alignments (Note that there are probably some de novo transcripts that align >=95% to the same known transcript). Of these `r length(unique(transcripts_covered_by_denovo$sseqid[transcripts_covered_by_denovo$num_match_all == 1]))`
 match only that known transcript and no others by the BLAST search. `r length(unique(filter(ungroup(transcripts_covered_by_denovo), qcovhsp < 50)$sseqid))` of the genes with >=95% known transcript alignments cover less than 50% of the de novo transcript.
 
See section [Known transcripts with >95% coverage from one de novo transcript.].
 
 With a threshold of 75% coverage `r transcripts_covered_by_denovo_diffcov['75']` known transcripts are represented by the de novo transcripts.
 
See section [Transcripts matched by percentage coverage.].
