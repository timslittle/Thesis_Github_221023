---
title: "TL19-07_Audrey_24h_chabaudi"
date: "17/06/2020"
output: 
  html_document:
    theme: cosmo
    code_download: true
    toc: true
    number_sections: true
    toc_float:
      collapsed: false
      smooth_scroll: true
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = FALSE, 
                      results = TRUE, 
                      message = FALSE, 
                      warning = FALSE)

#for server
# knitr::opts_knit$set(root.dir = '~/data/tl19-07_chabaudi_24h_audreyMTbrugatSBP')
knitr::opts_knit$set(root.dir = 
                       "/Users/littlet/Dropbox (The Francis Crick)/Data/tl19-07_audreybrugat24hchabaudi")
#Note that the above doesn't give an error if the dir doesn't exist

options(scipen = 999) # Means that numbers are displayed normally not as 1e6 (1000000)
```

To take into account:

- SBP is more synchronous than MT, do we have counts?

- MT and SBP may seem very different due to differences in the amount of material for sequencing.

Suggestions:

- PCA of SBP on its own, and MT on its own, UMAP maybe too?

- Use DESeq2 to get the diff expr genes between time points and then use this to plot a PCA.

- z-score plots: Have a max/min expression heatmap instead of showing the median logTPM.

- Just remove the Unknown sample since it contributes nothing without an identity.

- The value of the expression threshold (variable: min_median) is very high (over 4 TPM) - is this reasonable?

Top_n_genes:

~~- Remove Unknown entirely by re-saving top_genes table. Also need to separate the top_n bit using rMT and SBP.~~

~~- Why is there a NULL printed right at the end? Issue with names~~

Questions:

- What day are these samples taken? d6?

- How many passages had 'SBP' been through?

- What are the differential counts of the samples taken? - Audrey's are on the Shared folder.

# Audrey's experimental description

24 Hours cycle P. chabaudi RNA seq.


Aim: Determine pir expression for each parasite stage in recently mosquito transmitted P. chabaudi parasites.


Principle: using a stabilate from recently mosquito transmitted P. chabaudi parasites infected C57BL/6 and extract RNA at each stage of parasite cycle (every 3 hours) during 24h. 


Animals: 4 C57BL/6 J CD45.1 males for stabilates thawing (2 in RL, 2 in NL) and 27 C57BL/6 J CD45.1 females for experiments (12 in NL and 15 in RL) (issued 17/08/2016).
	
* AV16-35	2 C57BL/6 J CD45.1 males		RL.

* AV16-36	2 C57BL/6 J CD45.1 males		NL.

* AV16-37	15 C57BL/6 J CD45.1 females	RL.

* AV16-38	12 C57BL/6 J CD45.1 females	RL.

Experiment:

* d-14	11am	 Infected 2 mice (males) with recently mosquito transmitted parasite stabilate (MTC tower 6 box 6.1 position 31-65 (late troph)) in NL (AV16-36).

* d-14	5pm	Infecte 2 mice (males) with recently mosquito transmitted parasite stabilate (MTC tower 6 box 6.1 position 31-65 (late troph)) in RL (AV16-35).

* d-7	11am	pass AV16-35 into 15 mice (females) 105 iRBC/ mouse IP (AV16-37) RL.

* d0	 2pm	smear 3 mice and bleeding .
 
* d0	 2-5pm 	pellet parasites and trizol of 2pm samples.
 
* d0	 5pm	smear 3 mice and bleeding .
 
* d0	 5-8pm 	pellet parasites and trizol 5pm samples.
 
* d0	 8pm 	smear 3 mice and bleeding.
 
* d0	 8-11pm 	pellet parasites and trizol 8pm samples.
 
* d0	 11pm	smear 3 mice and bleeding .
 
* d0	11pm-2am 	pellet parasites and trizol 11pm samples.
 
* d1	 2am	smear 3 mice and bleeding .
 
* d1	 2-5am 	pellet parasites and trizol of 2am samples.
 
* d1	 5am	smear 3 mice and bleeding .
 
* d1	 5-8am 	pellet parasites and trizol 5pm samples.
 
* d1	 8am 	smear 3 mice in each group and bleeding .
 
* d1	 8-11am 	pellet parasites and trizol 8pm samples.
 
* d1	 11am	smear 3 mice in each group and bleeding .
 
* d1	 11am 	bleeding 3 mice (AV16-37) and parasite culture.
 
* d1	11am-2pm 	pellet parasites and trizol 11pm samples.
 
* d1	 4-6pm	schizonte pellet and trizol.
 

Dates:

d-14 : 25/08/2016.
 
d-7 : 01/09/2016.
 
d0 : 08/09/2016.
 
d1 : 09/09/2016.
 

```{r loading_packages, include = FALSE, message = FALSE}
# Load the required packages

# library('tidyverse')
library('readr')
library('dplyr')
library('tidyr')
library('ggplot2')
library('DESeq2')
library("pheatmap")
library("RColorBrewer")
library('data.table')
library('gridExtra')
# library('apeglm')
# library('ashr')
library('tibble')
library('stringr')
# library('cowplot')
library('kableExtra')
library('viridis')
# library('VennDiagram')
library('corrplot')
library('reshape2')
library('circlize') # for circular plots
library('cluster')    # clustering algorithms
library('factoextra') # clustering algorithms & visualization
library('ggfortify') # so ggplot understands prcomp objects
library('ape') # for phylogeny plotting
library('dendextend') # for dendrogram plotting
library('readxl') # for reading in Excel spreadsheets
library('plotly')
library('scales')
library('processx') # for downloading the plotly plots
library('cowplot')
library('writexl')

library('devtools')
#These packages were installed using github
library('ComplexHeatmap')
library('ggbiplot')
library('ggpattern')

#Colour blind friendly palette
cbPalette <- c("#999999", "#E69F00", "#56B4E9", "#009E73", "#F0E442", "#0072B2", "#D55E00", "#CC79A7")
show_col(cbPalette)

#Want the defaults for arrange, mutate and summarise to be from dplyr
arrange <- dplyr::arrange
mutate <- dplyr::mutate
summarise <- dplyr::summarise
select <- dplyr::select
```

```{r global_save_var}
#Make this TRUE if you want to run this script and save all the plots.
global_save_var <- TRUE
```


```{r tpm, results = 'hide', message = FALSE}
# # Calculating the transcript-per-million 
# 
# We need to write a function to calculate the TPM from the count data we have generated. This function uses the 'chabaudi_transcript_lengths' object created in the chunk above and should generate errors if it detects discrepencies between the Geneids so that the wrong transcript length is not used.

tpm = function(count_data, lengths = chabaudi_transcript_lengths) {
  
  #Print an error if the id columns do not match
  # first if statement to test that both have a GeneID column
  if(any(grepl(colnames(lengths), 
               pattern = 'id', 
               ignore.case = T)) == T & any(grepl(colnames(count_data), 
                                                  pattern = 'Geneid', 
                                                  #This needs to be Geneid when some of the samples have 'id' in them
                                                  ignore.case = T)) == T){
    if(all(count_data[grep(colnames(count_data), 
                           pattern = 'Geneid', ignore.case = T)] == lengths[grep(colnames(lengths), 
                                                                             pattern = 'id', ignore.case = T)])) {
      print('Count data and length gene ids both match')
    } else {
      stop('Error: Count data and length gene ids DO NOT MATCH, please make sure they are ordered identically.')
    }
  } else {
    stop('Error: Count data and/or length table supplied do not have an id column.')
  }
  
  #Remove the id column from supplied count_data
  if(any(grepl(colnames(count_data), pattern = 'Geneid',ignore.case = T)) == T){
    counts_tpm = count_data[,-grep(colnames(count_data), pattern = 'Geneid', ignore.case = T)]
  } else{
    counts_tpm <- count_data}
  
  #Remove the id column from supplied lengths
  if(any(grepl(colnames(lengths), pattern = 'id', ignore.case = T)) == T){
    lengths.table = lengths[,-grep(colnames(lengths), pattern = 'id', ignore.case = T)]
  }else{
    lengths.table <- lengths}
  lengths.table = matrix(lengths.table)
  #This may make lengths.table a vector which can bring up some dimension problems in the following for loop
  
  #Now for the actual calculation
  rpm <- counts_tpm
  for (i in 1:dim(counts_tpm)[2]) {
    for (j in 1:dim(counts_tpm)[1]) {
      rpm[j,i] <- (counts_tpm[j,i]/(lengths.table[j]/1000))
    }
    scale.factor <- sum(rpm[,i])/(1E6)
    counts_tpm[,i] <- apply(rpm[,i,drop=F],1,function(x){x/scale.factor})
  }
  if(any(grepl(colnames(count_data), pattern = 'Geneid', ignore.case = T)) == T){
    counts_tpm = bind_cols(count_data[,grep(colnames(count_data), pattern = 'Geneid', ignore.case = T), drop = FALSE], 
                           counts_tpm)
  } 
  return(counts_tpm)
}
```

```{r agree function}

agree = function(input_list){
  for(i in 1:(length(input_list)-1)){
    input_list[[i+1]] = input_list[[i]][ input_list[[i]] %in% input_list[[i+1]] ]
  }
  return(input_list[[length(input_list)]])
}

disagree = function(input_list){
  for(i in 1:(length(input_list)-1)){
    input_list[[i+1]] = input_list[[i]][ !input_list[[i]] %in% input_list[[i+1]] ]
  }
  return(input_list[[length(input_list)]])
}

mround <- function(x,base){ 
  base*round(x/base) 
} 
```

```{r function_ordering}
ordering <- function(to_order, order_vector){
  order = unlist(sapply(order_vector, 
                        function(x){unique(str_subset(to_order, 
                                                      pattern = paste(x)))}))
  order_missing = unique(to_order[!to_order %in% order])
  unique(c(order, order_missing), fromLast = TRUE)
}
```

```{r pca_function}
pca_function <- function(input_ct, 
                         genevec = NULL, 
                         scale.pca = TRUE, 
                         three.dimensional = FALSE,
                         legend_settings = list(),
                         colornames = NULL){
  
  twentyfour_tpm_pca <- input_ct$tpm
  if(!is.null(genevec)){
    twentyfour_tpm_pca <- input_ct$tpm %>% filter(Geneid %in% genevec)
    
    ### Re-scaling the TPM data
    twentyfour_tpm_pca_rescale <- lapply(colnames(twentyfour_tpm_pca), 
                                         function(column_name){
                                           column <- getElement(twentyfour_tpm_pca, 
                                                                paste(column_name))
                                           if(is.numeric(column)){
                                             #is.numeric to avoid trying to scale the Geneid column
                                             tpm_scale_factor <- 1e6 / sum(column)
                                             tpm_scaled <- as.numeric(column*tpm_scale_factor)
                                           }else{
                                             tpm_scaled <- column
                                           }
                                           return(tpm_scaled)
                                         }) %>% 
      bind_cols
    
    colnames(twentyfour_tpm_pca_rescale) <- colnames(twentyfour_tpm_pca)
    twentyfour_tpm_pca <- twentyfour_tpm_pca_rescale
    ###
    
  }
  rownames(twentyfour_tpm_pca) <- twentyfour_tpm_pca$Geneid
  twentyfour_tpm_pca <- select(twentyfour_tpm_pca, -Geneid) %>% 
    prcomp(center = TRUE, scale. = scale.pca)
  #Need to look into what exactly scale and center are doing
  twentyfour_tpm_pca_var <- get_pca_var(twentyfour_tpm_pca)
  twentyfour_tpm_pca_coords <- data.frame(twentyfour_tpm_pca_var$coord)
  
  twentyfour_tpm_pca_coords <- data.frame(sample = rownames(twentyfour_tpm_pca_var$coord),
                                          PC1 = twentyfour_tpm_pca_coords$Dim.1,
                                          PC3 = twentyfour_tpm_pca_coords$Dim.3,
                                          PC2 = twentyfour_tpm_pca_coords$Dim.2) %>% 
    dplyr::mutate(stage = gsub(sample, pattern = '_[[:digit:]]$', replacement = '')) %>% 
    dplyr::mutate(time = str_split_fixed(stage, pattern = '_', n = 2)[,2]) %>% 
    dplyr::mutate(transmission = str_split_fixed(sample, pattern = '_', n = 3)[,1])
  
  if(is.null(colornames)){
    # colornames <- c(cbPalette, 'black', 'red')
    colornames <- viridis(length(unique(twentyfour_tpm_pca_coords$time)))
    colornames <- setNames(colornames, 
                           sort(unique(twentyfour_tpm_pca_coords$time)))
  }
  
  pca_importance <- as.data.frame(summary(twentyfour_tpm_pca)$importance)
  pc1_importance <- round(pca_importance$PC1[2]*100, digits = 1)
  pc2_importance <- round(pca_importance$PC2[2]*100, digits = 1)
  pc3_importance <- round(pca_importance$PC3[2]*100, digits = 1)
  
  if(three.dimensional){
    pl <- plot_ly(twentyfour_tpm_pca_coords, 
                  x  = ~PC1, y = ~PC2, z = ~PC3,  mode = 'markers',
                  type = 'scatter3d', color = ~time, text = ~sample,
                  colors = colornames,
                  # size = ~total_features,
                  marker = list(opacity = 1, size = 5),
                  symbol = ~transmission, 
                  symbols = c('circle','x')) %>% 
      layout(scene = list(xaxis = list(title = paste0('PC1 ',pc1_importance,'%')),
                          yaxis = list(title = paste0('PC2 ',pc2_importance,'%')),
                          zaxis = list(title = paste0('PC3 ',pc3_importance,'%'))))
  }else{
    pl <- plot_ly(twentyfour_tpm_pca_coords, 
                  x  = ~PC1, y = ~PC2,
                  type = 'scatter', mode = 'markers',
                  color = ~time, text = ~sample,
                  colors = colornames,
                  # size = ~total_features,
                  marker = list(opacity = 1, size = 16),
                  symbol = ~transmission, symbols = c('circle','x')) %>% 
      layout(xaxis = list(title = paste0('PC1 ',pc1_importance,'%')),
             yaxis = list(title = paste0('PC2 ',pc2_importance,'%')),
             legend = legend_settings)
  }
  pl
}
```

```{r function_draw_heatmap_chabaudi_24h}
# Function to draw a heatmap with a list of genes

order_vector <- c("Early.Rings",
                  "Early.Mid.Rings",
                  "Late.Mid.Rings",
                  "Late.Rings",
                  "Rings.Troph.conversion",
                  "Early.Trophs",
                  "Mid.Trophs",
                  "Late.Trophs")

# Note that there may seem to be discrepencies between the data and the heatmap because this function may be using the median and/or mean value of the TPM
draw_heatmap_chabaudi_24h <- function(genelist, 
                                scale = 'max', 
                                threshold = 0, 
                                datasets = twentyfour_ct, 
                                filter_tpm = NULL,
                                stage_diff = NULL, 
                                filter_stage = NULL, 
                                title_name = NULL, 
                                drop_stage = NULL, 
                                log_it = TRUE,
                                collate_samples_by_stage = TRUE,
                                order_by_med_tpm = TRUE,
                                mean_or_median = 'mean',
                                gene_names_for_title = NULL,
                                ...){
  #genelist <- cir_id
  #For de-bugging:
  
  # scale = 'max';
  # threshold = 0;
  # datasets = twentyfour_ct;
  # filter_tpm = NULL;
  # stage_diff = NULL;
  # filter_stage = NULL;
  # title_name = NULL;
  # drop_stage = NULL;
  # log_it = TRUE;
  # collate_samples_by_stage = TRUE;
  # order_by_med_tpm = TRUE;
  # mean_or_median = 'mean';
  
  # if(!is.null(datasets$tpm)){
  #   #Probably means only one dataset was input so lapply will malfunction
  #   datasets <- list(tpm = datasets)
  # }
  
  if(log_it == TRUE){
    threshold <- log1p(threshold)
    title <- 'log(TPM + 1)'
  }else{
    title <- 'TPM'
  }
  
  expt_tpms_top_genes = lapply(datasets, function(tpm_input){
    # tpm_input <- datasets[[1]]
    tpms = tpm_input$tpm %>% 
      #Melt the data frame for using dplyr
      filter(Geneid %in% genelist) %>% 
      melt(id.vars = 'Geneid', variable.name = 'sample', value.name = 'tpm') 
    
    if(collate_samples_by_stage){ 
      #Create a new variable 'stage' from the sample names without rep numbers
      tpms <- mutate(
        tpms, 
        stage = str_extract(
          sample,
          pattern = '.+(?=_[[:digit:]]{1,2})'
        )
      )
    }else{
      tpms <- mutate(tpms, 
                     stage = sample)
    }
    
    tpms <- mutate(tpms, time = str_split_fixed(sample, pattern = '_', n = 2)[,1]) %>% 
      #Convert the times given in 'h' to robustly coded times in 24h clock
      mutate(time = ifelse(grepl(time, pattern = '[[:digit:]]h$'), 
                           strptime(time, format="%Hh") %>% format(., "%Hh"),
                           time)) %>% 
      mutate(time = ifelse(grepl(time, pattern = '[[:digit:]](a|p)m'), 
                           strptime(time, format="%I%p") %>% format(., "%Hh"),
                           time))
    
    colnam = sort(unique(tpms$stage))
    
    if(mean_or_median == 'median'){
      tpms = tpms %>% 
        group_by(Geneid, stage, time) %>%  
        dplyr::summarise(mean_tpm = median(tpm)) %>%  
        group_by(stage) %>% 
        recast(Geneid ~ stage + time + 'mean_tpm', median) #recast into short-form for complex heatmap
    } else if (mean_or_median == 'mean'){
      tpms = tpms %>% 
        group_by(Geneid, stage, time) %>%  
        dplyr::summarise(mean_tpm = mean(tpm)) %>%  
        group_by(stage) %>% 
        recast(Geneid ~ stage + time + 'median_tpm', mean) #recast into short-form for complex heatmap
    }
    
    colnames(tpms) = c('Geneid',as.character(colnam))
    
    if(!is.null(order_vector)){
      tpms <- tpms[,
                   ordering(colnames(tpms),
                            c('Geneid',
                              order_vector))]
      #Ordering using the ordering function and order_vector defined in the functions section.
    }
    
    #Apply drop_stage
    if(!is.null(drop_stage)){
      tpms <- select(tpms, -!!(paste(drop_stage)))
    }
    #Apply stage_diff to get genes which are expressed higher in one stage than another
    if(!is.null(stage_diff)){
      if(is.na(stage_diff[1])|is.na(stage_diff[2])){
        stop('stage_diff must be a vector of two named stages to select genes with TPM greater in the former than the latter')
      }
      tpms <- tpms[select(tpms, paste(stage_diff[1])) > select(tpms, paste(stage_diff[2])), ]
    }
    #Apply filter_tpm
    if(!is.null(filter_tpm)){
      tpms <- filter_at(tpms, vars(-Geneid), any_vars(. > filter_tpm))
    }
    #Apply filter_stage to remove genes expressed below filter_tpm in that stage
    if(!any(is.null(filter_stage), is.null(filter_tpm))){
      tpms <- filter(tpms, paste(filter_stage) >= filter_tpm)
    }
    #Remove PCHAS_ from the gene names for simplicity
    # rownames(tpms) = gsub(as.character(tpms$Geneid), pattern = 'PCHAS_', replacement = '')
    #Use the protein names for ease of understanding
    rownames(tpms) = chabaudi_gene_info$handy_descriptions[match(tpms$Geneid, 
                                                           chabaudi_gene_info$Geneid)]
    tpms = select(tpms, -Geneid)
    
    if(log_it == TRUE){
      tpms <- log1p(tpms)
    }
    
    if(tpm_input$experiment %>%  is.null){
      tpm_input$experiment = ''
    }
    list = list(tpms, tpm_input$experiment)
    names(list) = c('tpm','experiment')
    return(list)
  })
  
  if(
    !all(
      unlist(
        lapply(
          expt_tpms_top_genes, 
          function(x) all(
            x$tpm < threshold
          )
        )
      )
    )
  ){
    if(scale %in% 'max'){
      maxcol <- my_max(unlist(lapply(expt_tpms_top_genes, 
                                     function(tpms){my_max(tpms$tpm)})))
    }else{
      maxcol = scale
    }
  }
  
  if(is.na(maxcol)|maxcol<1){maxcol <- 1}
  
  if(order_by_med_tpm){
    #Work out the order by median TPM
    medians_across_expt_mat <- as.matrix(
      sapply(
        lapply(
          expt_tpms_top_genes, 
          function(x){
            rowMedians(as.matrix(x$tpm),
                       na.rm = TRUE) 
          }
        ), 
        rbind
      )
    )
    tpm_order <- order(
      rowMedians(
        medians_across_expt_mat, 
        na.rm = TRUE),
      decreasing = TRUE
    )
  }
  
  #Applying the threshold last because NAs mess things up
  expt_tpms_top_genes <- lapply(expt_tpms_top_genes, function(expt){
    tpms <- expt$tpm
    tpms = apply(tpms, 2, function(x){
      ifelse(
        x >= threshold, 
        x, 
        NA
      )
    }
    ) 
    #Get NA for values under threshold
    list = list(tpms, expt$experiment)
    names(list) = c('tpm','experiment')
    return(list)
  })
  
  heatmaps = lapply(expt_tpms_top_genes, function(tpms){
    if(tpms$experiment != last(expt_tpms_top_genes)$experiment){
      #If it is the final element don't remove the row names
      rownames(tpms$tpm) = c()
    }
    #Setting the name if one is not provided
    if(is.null(title_name)){
      title_name = tpms$experiment
    }
    
    #Re-order both data.frames by the median highest expressed pirs
    if(order_by_med_tpm){
      tpms$tpm <- tpms$tpm[tpm_order,, drop = FALSE]
    }
    
    # print(nrow(tpms$tpm))
    #Drawing each heatmap
    ht = Heatmap(tpms$tpm, 
                 name = 'TPM', 
                 col = colorRamp2(c(threshold, 
                                    maxcol/4, 
                                    maxcol/2, 
                                    3*maxcol/4, 
                                    maxcol), 
                                  viridis(5)),
                 cluster_rows = FALSE, 
                 cluster_columns = FALSE,
                 column_title = paste(title_name),
                 column_title_gp = gpar(fontsize = 7),
                 column_names_gp = gpar(fontsize = 7),
                 row_names_gp = gpar(fontsize = ifelse(
                   nrow(tpms$tpm) > 13, 
                   12*(13/nrow(tpms$tpm)), 
                   12)
                 ),
                 na_col = 'white', border = TRUE,
                 heatmap_legend_param = list(
                   title = paste(title), 
                   at = round(
                     c(threshold, 
                       maxcol/4, 
                       maxcol/2, 
                       3*maxcol/4, 
                       maxcol), 
                     digits = 1)
                 )
                 # ,...
    )
  })
  
  ht_list = Reduce('+', heatmaps) #To add the list elements together
  draw(ht_list, 
       row_title_side = 'left',
       column_title = bquote(~italic('P. chabaudi')~'24h asexual life cycle stage - '~italic(.(gene_names_for_title))~'genes'), 
       column_title_side = 'bottom',
       heatmap_legend_side = 'left')
}
```

```{r plotly_biplot_function}
plot_ly_biplot <- function(pca_object = twentyfour_tpm_pca, 
                           prin_components = c(1,2,3),
                           fontsize = 7,
                           scale.loads = 600,
                           separate_multigene = FALSE,
                           three_dimensions = FALSE,
                           col_var = 'time',
                           gene_info = chabaudi_gene_info,
                           textposition = "top right"){
  
  #Check that three components are provided for three dimensional biplot
  if(three_dimensions){
    if(length(prin_components) != 3){
      stop('For three dimensions, three principal components must be given for prin_components argument')
    }
  }
  
  pca_object_rotations <- rownames_to_column(data.frame(pca_object$rotation), 
                                             var = 'sample')  %>% 
    dplyr::mutate(stage = gsub(sample, pattern = '_[[:digit:]]$', replacement = '')) %>% 
    dplyr::mutate(time = str_split_fixed(stage, pattern = '_', n = 2)[,2]) %>% 
    dplyr::mutate(transmission = str_split_fixed(sample, pattern = '_', n = 3)[,1])
  
  #Setting the colours, which come from each life cycle experiment, called 'stage'.

  
  colornames <- setNames(
    viridis(
      length(
        unique(
          getElement(
            pca_object_rotations, 
            paste(col_var)
          )))),
    sort(
      unique(
        getElement(
          pca_object_rotations, 
          paste(col_var)
        ))))
  
  
  pca_object_loadings <- data.frame(Geneid = rownames(pca_object$x),
                                    pca_object$x)
  
  pca_object_loadings$Geneid <- paste0(
    str_replace(
          as.character(pca_object_loadings$Geneid),
          pattern = ' ',
          replacement = ''),
    ' ',
    gene_info$handy_descriptions
    [
      match(
        c(str_replace(
          as.character(pca_object_loadings$Geneid),
          pattern = ' ',
          replacement = '')
        ),
        gene_info$Geneid
      )
      ]
  )
  
  if(separate_multigene){
    #If the gene is a fam or a fam gene we want to know - haven't excluded pseudogenes here
    pca_object_loadings$multigene <- ifelse(
      #if it doesn't have fam or fam-something in its name then just say gene
    is.na(
      str_extract(
        pca_object_loadings$Geneid,
        pattern = 'fam-.|fam'
      )
    ),
    'Gene loadings',
    paste0(
      str_extract(
        pca_object_loadings$Geneid,
        pattern = 'fam-.|fam'
      ),
      ' gene loadings'
    )
  )
}else{
  pca_object_loadings$multigene <- rep('Gene loadings',
                                       stages = nrow(pca_object_loadings))
}

#Degrees of variation for the axes
pca_importance <- as.data.frame(summary(pca_object)$importance)
pc_importance_1 <- round(pca_importance[2,prin_components[1]]*100, digits = 1)
pc_importance_2 <- round(pca_importance[2,prin_components[2]]*100, digits = 1)
if(three_dimensions){
  pc_importance_3 <- round(pca_importance[2,prin_components[3]]*100, digits = 1)
}

#scale.loads controls how long the lines are, the longer they are the more prominent the loadings but the less
# obvious the genes.

pl <- plot_ly()

#For the font of the labels
t <- list(
  size = fontsize
  )

#For loop to add the PCA lines of the samples
for(k in 1:nrow(pca_object_rotations)) {
  #Have 0 so that the line comes from the origin (0,0)
  #PC first
  x <- c(0, pca_object_rotations[k,(prin_components[1]+1)])*scale.loads
  #PC second
  y <- c(0, pca_object_rotations[k,(prin_components[2]+1)])*scale.loads
  
  if(three_dimensions){
    #PC third
    z <- c(0, pca_object_rotations[k,(prin_components[3]+1)])*scale.loads
    df_plotly <- data.frame(x = x, 
                            y = y, 
                            z=z,
                            stage = getElement(pca_object_rotations, 
                                               paste(col_var))[k],
                            sample = pca_object_rotations$sample[k])
  }else{
    df_plotly <- data.frame(x = x, 
                            y = y,
                            stage = getElement(pca_object_rotations, 
                                               paste(col_var))[k],
                            sample = pca_object_rotations$sample[k])
  }
  
  #colour based on sample
  color <- colornames[
    match(
      getElement(
        pca_object_rotations, 
        paste(col_var)
      )[k], 
      rev(names(colornames)
      )
    )
    ]
  
  #Add these to the plot
  #To avoid duplication in the legend don't show it if the name is duplicated
  if(duplicated(getElement(pca_object_rotations, paste(col_var)))[k]){
    showlegend <- FALSE
  }else{
    showlegend <- TRUE
  }
  
  #Add the lines for the samples depending on their position in the PCA
  if(three_dimensions){
    pl <- pl %>%
      add_trace(data = df_plotly,
                x=~x,
                y=~y,
                z=~z,
                type='scatter3d',
                mode='line',
                color = ~stage,
                colors = colornames,
                line = list(width = 2),
                text = pca_object_rotations[k,1],
                name = getElement(pca_object_rotations, paste(col_var))[k],
                opacity = 1,
                showlegend = showlegend,
                legendgroup = getElement(pca_object_rotations, paste(col_var))[k],
                #Note that 3d plots only accept a few shapes e.g. hexagon is not accepted
                symbols = c('circle', 
                            'circle-open',
                            'square',
                            'square-open',
                            'x',
                            'diamond')) %>% 
            add_text(x = df_plotly$x[2],
               y = df_plotly$y[2],
               z = df_plotly$z[2],
               text = df_plotly$sample, 
               textfont = t,
               textposition = textposition,
               showlegend = ifelse(k == 1, TRUE, FALSE), #Only want this option to be TRUE once
               legendgroup = 'Toggle text',
               name = 'Toggle text')
  }else{
    pl <- pl %>% 
      add_trace(data = df_plotly,
                x=~x,
                y=~y,
                type='scatter',
                mode='line',
                color = ~stage,
                colors = colornames,
                line = list(width = 2),
                text = pca_object_rotations[k,1],
                name = getElement(pca_object_rotations, 
                                  paste(col_var))[k],
                opacity = 1,
                showlegend = showlegend,
                legendgroup = getElement(pca_object_rotations, 
                                         paste(col_var))[k],
                symbols = c('circle', 
                            'circle-open',
                            'square',
                            'square-open',
                            'x',
                            'diamond')) %>% 
      #I don't know why it only works if we put the symbols argument here and not in the add_trace later??
      add_text(x = df_plotly$x[2],
               y = df_plotly$y[2],
               text = df_plotly$sample,
               textfont = t,
               textposition = textposition,
               showlegend = ifelse(k == 1, TRUE, FALSE), #Only want this option to be TRUE once
               legendgroup = 'Toggle text',
               name = 'Toggle text')
  }
}

#Adding the gene loadings

if(three_dimensions){
  #Make data frame of the gene loadings
  pca_object_loadings_df <- select(data.frame(pca_object_loadings), c(Geneid, 
                                                                      multigene, 
                                                                      paste0('PC', prin_components[1]),
                                                                      paste0('PC', prin_components[2]),
                                                                      paste0('PC', prin_components[3])))
  colnames(pca_object_loadings_df) <- c('Geneid',
                                        'multigene',
                                        'prin_com_1',
                                        'prin_com_2',
                                        'prin_com_3')
  pl <- pl %>% 
    add_trace(data = pca_object_loadings_df, 
              inherit = FALSE,
              x = ~prin_com_1, 
              y = ~prin_com_2, 
              z = ~prin_com_3,
              type = 'scatter3d', 
              mode = 'markers',
              marker = list(color = 'black',
                            size = 4,
                            opacity = 0.7),
              text = ~Geneid,
              name = ~multigene,
              symbol = ~multigene,
              showlegend = TRUE,
              legendgroup = ~multigene) %>% 
    layout(
      scene = list(
        xaxis = list(
          title = paste0(
            'PC', 
            prin_components[1], 
            ' ', 
            pc_importance_1,
            '%'
          )
        ),
        yaxis = list(
          title = paste0(
            'PC', 
            prin_components[2], 
            ' ',
            pc_importance_2,
            '%'
          )
        ),
        zaxis = list(
          title = paste0(
            'PC', 
            prin_components[3], 
            ' ',
            pc_importance_3,
            '%'
          )
        )
      )
    )
    }else{
      #Make data frame of the gene loadings
      pca_object_loadings_df <- select(data.frame(pca_object_loadings), 
                                       c(Geneid, 
                                         multigene, 
                                         paste0('PC', prin_components[1]),
                                         paste0('PC', prin_components[2])))
      colnames(pca_object_loadings_df) <- c('Geneid',
                                            'multigene',
                                            'prin_com_1',
                                            'prin_com_2')
      pl <- pl %>% 
        add_trace(data = pca_object_loadings_df, 
                  inherit = FALSE,
                  x = ~prin_com_1, 
                  y = ~prin_com_2,
                  type = 'scatter', 
                  mode = 'markers',
                  marker = list(color = 'black',
                                size = 6,
                                opacity = 0.9),
                  text = ~Geneid,
                  name = ~multigene,
                  symbol = ~multigene,
                  showlegend = TRUE,
                  legendgroup = ~multigene) %>% 
        layout(
          xaxis = list(
            title = paste0(
              'PC', 
              prin_components[1], 
              ' ', 
              pc_importance_1,
              '%'
            )
          ),
          yaxis = list(
            title = paste0(
              'PC', 
              prin_components[2], 
              ' ',
              pc_importance_2,
              '%'
            )
          )
        )
    }
pl
}

#For debugging
# k <- 6

#Switching around the add_text and add_trace for the 'Toggle text' (so that it goes first) seems to bugger up the colours
```

```{r function_mround}
mround <- function(x,base){ 
  base*ceiling(x/base) 
} 
```

```{r function_my_max}
my_max <- function(x) ifelse( !all(is.na(x)), max(x, na.rm=T), NA) #max robust to NAs
```

```{r function_uniquify}
uniquify <- function(vector_names, first_one = TRUE){
  new_vector <- c()
  df_num <- data.frame(names = unique(vector_names), rep = 1)
  if(first_one){
    duplicated_names <- unique(vector_names[duplicated(vector_names)])
  }else{
    duplicated_names <- c()
  }
  for(i in 1:length(vector_names)){
    if(vector_names[i] %in% duplicated_names|!first_one){
    name <- paste(vector_names[i],
                  df_num$rep[match(vector_names[i], df_num$names)],
                  sep = '_')
    #Increase rep counter
    df_num$rep[match(vector_names[i], df_num$names)] <- df_num$rep[match(vector_names[i], df_num$names)] + 1
    new_vector[i] <- name
    }else{
      new_vector[i] <- vector_names[i]
    }
  }
  new_vector
}
```

```{r function_firstup}
#Capitalize first letter
firstup <- function(x) {
  substr(x, 1, 1) <- toupper(substr(x, 1, 1))
  x
}
```

```{r function_density_samples}
density_samples = function(input, save = FALSE){
  #Get some colours for the lines
  # colours = rainbow_hcl(length(colnames(input$tpm)[-1]))
  colours = rep_len(cbPalette, length.out = length(colnames(input$tpm)[-1]))
  list_dens = lapply(colnames(input$tpm)[-1], function(sample){
    data = as.numeric(unlist(select(input$tpm, paste(sample))))
    dens = density(log1p(data), bw = bw_mean)
    #Use the index of the column to get the colour
    colouring = colours[grep(colnames(input$tpm)[-1], pattern = paste(sample))]
    list_return = list(dens, colouring)
    names(list_return) = c('dens','colouring')
    list_return
  })
  max_dens = max(unlist(lapply(list_dens, function(x){max(x$dens$y)})))
  max_x = max(unlist(lapply(list_dens, function(x){max(x$dens$x)})))
  line_width = 1
  par(new=FALSE)
  if(save){
    pdf(file = paste0(input$experiment, '_tl19-07_densityplot_fixedbw.pdf'), 
        width = 15/2.54, 
        height = 11.5/2.54)
  }
  lapply(seq_along(list_dens), function(index){
    x = list_dens[[index]]
    if(index <= 9){
      plot(x$dens, 
           xlim = c(0, max_x), 
           ylim = c(0,max_dens), 
           type = 'l', 
           col = x$colouring,
           main = paste(input$experiment),
           lwd = line_width)
    }else if(index <= 18){
      plot(x$dens, 
           xlim = c(0, max_x), 
           ylim = c(0,max_dens), 
           type = 'l', 
           col = x$colouring,
           main = paste(input$experiment),
           lwd = line_width,
           lty = 2)
    } else {
      plot(x$dens, 
           xlim = c(0, max_x), 
           ylim = c(0,max_dens), 
           type = 'l', 
           col = x$colouring,
           main = paste(input$experiment),
           lwd = line_width,
           lty = 3)
    }
    abline(v = log1p(min_median))
    legend(max_x-4, max_dens, 
           legend = paste(colnames(input$tpm)[-1]), 
           col = colours,
           lty = c(rep(1, times = 9), rep(2, times = 9), rep(3, times = 9)),
           cex = 0.5)
    par(new=TRUE)})
  if(save){
    dev.off()
  }
}
```

```{r function_total_tpm_expression}
total_tpm_expression <- function(list_genes, 
                                 save = FALSE,
                                 tpm_data = twentyfour_ct,
                                 stage_str_extract_regex_pattern = '(?<=_).+(?=_[[:digit:]]+)|sch.culture'){
  lapply(names(list_genes), 
         function(list_name){
           paste(list_name)
           gene_id <- getElement(list_genes, paste(list_name))
           list_tpms_line <- lapply(tpm_data, 
                                    function(input){
             tpm_data = input$tpm %>% 
               filter(Geneid %in% gene_id) %>% 
               melt(id.vars = 'Geneid', variable.name = 'sample', value.name = 'tpm') %>% 
               mutate(stage = str_extract(sample, 
                                          pattern = paste(stage_str_extract_regex_pattern))) %>% 
               group_by(stage, sample) %>% 
               dplyr::summarise(total_tpm = sum(tpm))
             
             #All genes detected
             tpm_data_all_genes <- input$tpm %>% 
               melt(id.vars = 'Geneid', variable.name = 'sample', value.name = 'tpm') %>% 
               mutate(stage = unlist(lapply(strsplit(as.character(sample), split = '_'),
                                            `[`,
                                            1))) %>% 
               # filter(tpm > threshold) %>% 
               group_by(stage, sample) %>% 
               dplyr::summarise(total_tpm = n()) %>% 
               ungroup %>%  
               group_by(stage) %>% 
               dplyr::summarise(total_tpm_median = median(total_tpm),
                                Number_of_replicates = n(),
                                total_tpm_max = max(total_tpm),
                                total_tpm_min = min(total_tpm)) %>% 
               arrange(stage)
             
             #Make stages with no cirs in the sample give a zero 
             if(!all(colnames(input$tpm) %in% tpm_data$sample)){
               missing_stages = colnames(input$tpm)[-1][!colnames(input$tpm)[-1] %in% tpm_data$sample]
               missing_stages_data_zero = data.frame(lapply(missing_stages, function(missing_st){
                 data.frame(stage = unlist(str_extract(missing_st, 
                                                       pattern = paste(stage_str_extract_regex_pattern))),
                            sample = missing_st,
                            total_tpm = 0)
               }))
               tpm_data = bind_rows(tpm_data, missing_stages_data_zero)
             }
             
             #Add experiment column
             tpm_data$experiment = rep(input$experiment, times = nrow(tpm_data))
             max_tpm = if(max(tpm_data$total_tpm) < 10){
               c(seq(0,mround(max(tpm_data$total_tpm),1),1))
             }else{
               c(seq(0,mround(max(tpm_data$total_tpm),5),5))
             }
             
             #Get the average data for the line graph
             tpm_data_line = tpm_data %>% 
               ungroup %>% 
               group_by(stage, experiment) %>% 
               dplyr::summarise(total_tpm_median = median(total_tpm),
                                Number_of_replicates = n(),
                                total_tpm_max = max(total_tpm),
                                total_tpm_min = min(total_tpm)) %>% 
               arrange(stage)
             
             tpm_data_line$total_tpm_median_allgenes <- tpm_data_all_genes$total_tpm_median
             
             return(tpm_data_line)
           })
           
           tpm_data_line = bind_rows(list_tpms_line)
           #Apply ordering if it is specified
           if(!is.null(order_vector)){
             tpm_data_line$stage = factor(tpm_data_line$stage, 
                                          levels = ordering(tpm_data_line$stage,
                                                            order_vector))
           }
           # tpm_data_line$threshold = rep(threshold, nrow(tpm_data_line))
           
           tpm_data_line
           
           #Calculate the range for the y value to make it look nicer
           if(max(
             tpm_data_line$total_tpm_max
           ) >= 500){
             max_tpm <- c(
               seq(
                 0,
                 mround(
                   max(
                     tpm_data_line$total_tpm_max
                   ),
                   500),
                 length.out = 11)
             )
           }else{
             max_tpm <- c(
               seq(
                 0,
                 mround(
                   max(
                     tpm_data_line$total_tpm_max
                   ),
                   10),
                 length.out = 11)
             )
           }
           # max_tpm <- seq(
           #       0,
           #       mround(
           #         max(
           #           tpm_data_line$total_tpm_max),
           #         500),
           #       by = 500)
           y = ggplot(data = tpm_data_line, aes(x = stage, y = total_tpm_median, 
                                                fill = experiment, group = experiment)) +
             geom_bar(position = position_dodge2(preserve = 'single'),
                      stat = 'identity') +
             scale_fill_manual(values = c(cbPalette, 'red', 'purple')[1:(length(unique(tpm_data_line$experiment)))]) +
             geom_errorbar(aes(x = stage,
                               ymax = total_tpm_max, 
                               ymin = total_tpm_min),
                           position = position_dodge2(preserve = 'single')) +
             scale_y_continuous(breaks = max_tpm) +
             theme_classic() +
             theme(axis.title.x=element_blank(),
                   axis.text.x=element_text(angle = 90, 
                                            size = 10, 
                                            vjust = 0.5),
                   axis.text.y = element_text(size = 5),
                   axis.title.y = element_text(size = 8),
                   legend.title = element_text(size = 7),
                   legend.text = element_text(size = 5),
                   legend.key.size = unit(3,'mm'),
                   legend.key.width = unit(2,'mm')) +
             scale_size(range = c(0,3)) +
             ylab(
               bquote('total '~italic(.(list_name))~' TPM')
             )
           if(save == TRUE){
             ggsave2(paste0('tl20-05_',
                            gsub(list_name, 
                                 pattern  = ' ', 
                                 replacement = '_'),
                            '_totalTPM_barchart.pdf'),
                     plot = y,
                     dpi = 300,
                     width = 15,
                     height = 10,
                     units = 'cm')
           }
           y
         })
}
```

```{r function_total_tpm_expression_stacked}
total_tpm_expression_stacked <- function(
  list_genes, 
  save = FALSE,
  tpm_data = twentyfour_ct,
  stage_str_extract_regex_pattern = '(?<=[[:digit:]]h_).+(?=_[[:digit:]]+)|sch.culture',
  stack_genes = cir_id,
  stack_names = c('Yes',
                  'No'),
  stack_label = 'Cir genes',
  stack_grouping = TRUE
){
  lapply(names(list_genes), 
         function(list_name){
           paste(list_name)
           gene_id <- getElement(list_genes, paste(list_name))
           list_tpms_line <- lapply(tpm_data, 
                                    function(input){
                                      tpm_data <- input$tpm %>% 
                                        filter(Geneid %in% gene_id) %>% 
                                        melt(id.vars = 'Geneid', variable.name = 'sample', value.name = 'tpm') %>% 
                                        mutate(stage = str_extract(sample, 
                                                                   pattern = paste(stage_str_extract_regex_pattern)),
                                               # stack_group = ifelse(
                                               #   Geneid %in% stack_genes, #If the gene is in stack_genes
                                               #   ifelse(
                                               #     stack_grouping, #If stack_grouping is TRUE, use the group name from stack_names (the first element), otherwise use the gene name (useful is stack_genes is big e.g. cir_id)
                                               #     stack_names[1],
                                               #     Geneid
                                               #   ),
                                               #   stack_names[2]) #stack_names[2] is the negative name e.g. 'No'
                                               stack_group = case_when(
                                                 Geneid %in% stack_genes & stack_grouping ~ stack_names[1],
                                                 Geneid %in% stack_genes & !stack_grouping ~ Geneid,
                                                 TRUE ~ stack_names[2]
                                               )
                                        ) %>% 
                                        group_by(stage, sample, stack_group) %>% 
                                        dplyr::summarise(total_tpm = sum(tpm))
                                      
                                      #Make stages with no cirs in the sample give a zero 
                                      if(!all(colnames(input$tpm) %in% tpm_data$sample)){
                                        missing_stages = colnames(input$tpm)[-1][!colnames(input$tpm)[-1] %in% tpm_data$sample]
                                        missing_stages_data_zero = data.frame(lapply(missing_stages, 
                                                                                     function(missing_st){
                                                              data.frame(stage = unlist(str_extract(missing_st, 
                                                                                                    pattern = paste(stage_str_extract_regex_pattern))),
                                                                         sample = missing_st,
                                                                         total_tpm = 0)
                                                            })
               )
               tpm_data = bind_rows(tpm_data, missing_stages_data_zero)
             }
             
             #Add experiment column
             tpm_data$experiment = rep(input$experiment, times = nrow(tpm_data))
             max_tpm = if(max(tpm_data$total_tpm) < 10){
               c(seq(0,mround(max(tpm_data$total_tpm),1),1))
             }else{
               c(seq(0,mround(max(tpm_data$total_tpm),5),5))
             }
             
             #Get the average data for the line graph
             tpm_data_line = tpm_data %>% 
               ungroup %>% 
               group_by(stage, experiment, stack_group) %>% 
               dplyr::summarise(total_tpm_median = median(total_tpm),
                                Number_of_replicates = n(),
                                total_tpm_max = max(total_tpm),
                                total_tpm_min = min(total_tpm)) %>% 
               arrange(stage)
             
             return(tpm_data_line)
           })
           
           tpm_data_line <- bind_rows(list_tpms_line)
           #Apply ordering if it is specified
           if(!is.null(order_vector)){
             tpm_data_line$stage = factor(tpm_data_line$stage, 
                                          levels = ordering(tpm_data_line$stage,
                                                            order_vector))
           }
           
           tpm_data_line
           
           #Calculate the range for the y value to make it look nicer
           if(max(
             tpm_data_line$total_tpm_max
           ) >= 500){
             max_tpm <- c(
               seq(
                 0,
                 mround(
                   max(
                     tpm_data_line$total_tpm_max
                   ),
                   500),
                 length.out = 11)
             )
           }else{
             max_tpm <- c(
               seq(
                 0,
                 mround(
                   max(
                     tpm_data_line$total_tpm_max
                   ),
                   10),
                 length.out = 11)
             )
           }
           # max_tpm <- seq(
           #       0,
           #       mround(
           #         max(
           #           tpm_data_line$total_tpm_max),
           #         500),
           #       by = 500)
           y <- ggplot(data = tpm_data_line, 
                       aes(
                         x = experiment,
                         y = total_tpm_median, 
                         fill = stack_group
                       )
           ) +
             geom_bar(position = position_stack(),
                      stat = 'identity') +
             scale_fill_manual(
               limits = unique(tpm_data_line$stack_group),
               values = setNames(cbPalette[1:length(unique(tpm_data_line$stack_group))],
                                 unique(tpm_data_line$stack_group))
               #Need to have limits and values otherwise when there are only cir genes (i.e. only 'Yes') the colour 
               # palette will mess up and only use one, wrong colour. Limits tells it there are always two values.
             ) +
             labs(fill = stack_label) +
             # scale_y_continuous(breaks = max_tpm) +
             theme_classic() +
             theme(axis.title.x=element_blank(),
                   axis.text.x=element_text(angle = 90, 
                                            size = 10, 
                                            vjust = 0.5),
                   axis.text.y = element_text(size = 5),
                   axis.title.y = element_text(size = 8),
                   legend.title = element_text(size = 7),
                   legend.text = element_text(size = 5),
                   legend.key.size = unit(3,'mm'),
                   legend.key.width = unit(2,'mm')) +
             scale_size(range = c(0,3)) +
             ylab(
               bquote('total '~italic(.(list_name))~' TPM')
             ) + 
             facet_grid(.~stage) +
             theme(strip.text.x = element_text(size=4, face = 'bold', angle = 45),
                   strip.background = element_rect(colour="black", fill="lightgrey"))
           if(save == TRUE){
             ggsave2(paste0('tl20-08_',
                            gsub(list_name, 
                                 pattern  = ' ', 
                                 replacement = '_'),
                            '_totalTPM_barchart.pdf'),
                     plot = y,
                     dpi = 300,
                     width = 15,
                     height = 10,
                     units = 'cm')
           }
           y
         })
}
```

The _cir_ gene names were downloaded using a search of PlasmoDB _P. chabaudi_ genome.

```{r cir_id, message=FALSE, results='hide'}

# Getting the cir gene names and transcript lengths needed for calculating the transcript-per-million

chabaudi_gene_info = read.csv('chabaudi_PccAS_PlasmoDBv44_geneinformation_GenesByTaxon_Summary.csv',
                              header = TRUE,
                              stringsAsFactors = FALSE)
#.txt file is weirdly truncated, don't use it

chabaudi_transcript_lengths = select(chabaudi_gene_info, c(Gene.ID, Transcript.Length)) %>% 
  arrange(Gene.ID)

cir_info = chabaudi_gene_info %>% 
  select(Gene.ID, Product.Description, Transcript.Length) %>% 
  filter(Product.Description == 'PIR protein')
nrow(cir_info)

#Brugat 2017 cirs
list.files()
brugat_cir_names = read_xlsx('chabaudi_pir_cir_genes_brugat_2017_nmicrobiol2016276-s4.xlsx') %>% 
  .$id
length(brugat_cir_names)
#Two extra genes compared to from PlasmoDB

#Adam Reid Personal Comm 2019 cirs
reid_cir_clade = read.table('AdamReid_chabaudi_PccAS_v3_aa.pir.clades.simple.txt',
                            header = FALSE,
                            stringsAsFactors = FALSE,
                            sep = '\t',
                            col.names = c('Geneid','clade'))
reid_cir_names = reid_cir_clade$Geneid
length(reid_cir_names)
#An extra gene compared to Brugat

brugat_cir_names[!brugat_cir_names %in% cir_info$Gene.ID] #Not annotated as cirs by PlasmoDB v Brugat
cir_info$Gene.ID[!cir_info$Gene.ID %in% brugat_cir_names] #Not annotated as cirs by Brugat 2017? v PlasmoDB
cir_info$Gene.ID[!cir_info$Gene.ID %in% reid_cir_names] #Not annotated as cirs by Reid v PlasmoDB
reid_cir_names[!reid_cir_names %in% brugat_cir_names] #Not annotated as cirs by Brugat v Reid
reid_cir_names[!reid_cir_names %in% cir_info$Gene.ID] #Not annotated as cirs by PlasmoDB v Reid

#Adam Reid's list contains all the pirs we should assume, however I don't understand why it is missing the 'conserved rodent pir' - need to discuss this with him.
#After extensive discussion it has been decided that due to dissimilarity and lack of an InterPro pir domain the
# pan-rodent is not a pir gene

reid_missing_cir = cir_info$Gene.ID[!cir_info$Gene.ID %in% reid_cir_names]

#Add the missing cir to the list of cirs and their clades
cir_clade_info <- reid_cir_clade %>% 
  mutate(SorL = str_extract(clade, 
                            pattern = '(L|S(?=[[:digit:]]))|ancestral|unk|pir-like'))
write_delim(cir_clade_info,
            '../standard_files/Pchabaudi_pir_clades.txt',
            delim = '\t')

cir_info = chabaudi_gene_info %>% 
  select(Gene.ID, 
         Product.Description, 
         Transcript.Length) %>% 
  filter(Gene.ID %in% c(reid_cir_names)) %>% 
  mutate(Geneid = Gene.ID)
cir_transcript_lengths = select(cir_info, -Product.Description, -Gene.ID)

cir_id <- cir_info$Gene.ID
length(cir_id)

cir_id_no_anc_or_rodcon <- cir_id[!cir_id %in% 'PCHAS_0101200'] 

#How many cirs are present on each chromosome?

cir_tbl = as_tibble(data.frame(Geneid = cir_id))
cir_chrom_tbl <- cir_tbl %>% 
  mutate(chrom = unlist(sapply(lapply(sapply(as.character(cir_tbl$Geneid), strsplit,
                                             split = ''), '[', 7:8), 
                               paste, collapse = ''))) 
cir_chrom_tbl %>% 
  group_by(chrom) %>% 
  dplyr::summarise(number_of_cirs_in_each_chromosome = n(),
                   percentage_of_all_cirs = round(n()/nrow(cir_tbl), 3)*100) %>% 
  dplyr::arrange(desc(percentage_of_all_cirs))


#How many in each clade?
cir_clade_tbl = reid_cir_clade %>% 
  as_tibble() %>% 
  group_by(clade) %>% 
  dplyr::summarise(n())
cir_clade_tbl

chabaudi_gene_info <- dplyr::rename(chabaudi_gene_info, 
                             Geneid = Gene.ID,
                             Description = Product.Description)
```

```{r chapl_info}
cir_chapl_aapl_info <- read_xlsx('Brugat2017_pirexpressiondata_41564_2017_BFnmicrobiol2016276_MOESM25_ESM.xlsx',
                            sheet = 1) %>% 
  filter(id %in% cir_id) %>%
  mutate(
    Geneid = id,
    locus_type = `Locus type`,
    chapl_aapl = ifelse(is.na(`Locus type`),
                        NA,
                        paste0(Subtelomere, 
                               '_',
                               `Locus type`)
    )
  ) %>% 
  select(Geneid, locus_type, chapl_aapl)

cir_chapl_aapl_info %>% 
  mutate(chrom = str_extract(Geneid, pattern = '(?<=PCHAS_)[:digit:]{2}'),
         locus_type = ifelse(is.na(locus_type), 'None', locus_type)) %>% 
  group_by(chrom, 
           locus_type) %>% 
  summarise(num_subfam = n_distinct(Geneid))
```


```{r gene_info, message = FALSE, results='hide'}

#No redundancy
two.transcript <- chabaudi_gene_info %>% 
  dplyr::count(Geneid) %>% 
  filter(n > 1)

```

```{r handier_descriptions}
chabaudi_gene_info$is_putative <- ifelse(
  str_detect(
    chabaudi_gene_info$Description,
    pattern = 'putative'
  ),
  'Yes',
  'No'
)
  
chabaudi_gene_info$handy_descriptions <- case_when( 
  #Handy function for avoiding nested, messy ifelse statements
  str_detect(
    chabaudi_gene_info$Description, 
    pattern = 'early transcribed membrane protein'
  ) ~ 
    'ETRAMP',
  str_detect(
  chabaudi_gene_info$Description, 
    pattern = 'PIR protein'
  ) ~ 
    'PIR',
  str_detect(
    chabaudi_gene_info$Description, 
    pattern = 'hypothetical'
  ) ~ 
    'hypothetical',
  str_detect(
    chabaudi_gene_info$Description, 
    pattern = '(conserved Plasmodium)|(conserved protein, unknown function)'
  ) ~ 
    'cons.',
  TRUE ~ #This applies the case to all remaining
    str_extract(  
      str_remove_all( 
        #Remove all applies across all the patterns instead of just one.
        chabaudi_gene_info$Description, 
        pattern = '( protein)|( protein, )|(, pseudogene)|(, putative)' 
        #Remove the words protein and spaces for the word.
      ),
      pattern = '.{1,10}' 
      #Take the first 10 characters max.
    )
)

chabaudi_gene_info$handy_descriptions <- ifelse(
  grepl(chabaudi_gene_info$Description, pattern = 'pseudogene'),
  paste0(chabaudi_gene_info$handy_descriptions,
         '_ps'),
  paste0(chabaudi_gene_info$handy_descriptions)
)

chabaudi_gene_info$handy_descriptions <- uniquify(
  ifelse(
    chabaudi_gene_info$is_putative == 'Yes',
    paste0(chabaudi_gene_info$handy_descriptions, '_put'),
    paste0(chabaudi_gene_info$handy_descriptions)
  ),
  first_one = TRUE
)

#Annotations for individual pirs based on Frech and Chen 2013, PlasmoDB
chabaudi_gene_info$handy_descriptions[which(chabaudi_gene_info$Geneid == 'PCHAS_0101200')] <- 'PIR_highly_cons.'
# chabaudi_gene_info$handy_descriptions[which(chabaudi_gene_info$Geneid == 'PCHAS_0524800')] <- 'PIR_rodent_cons.'
chabaudi_gene_info$handy_descriptions[which(chabaudi_gene_info$Geneid == 'PCHAS_1100300')] <- 'PIR_SBP_high'
```


```{r function_featurecounts_to_table, results = 'hide', message = FALSE}

featurecounts_to_table = function(vector_of_files = NULL, 
                                  read_skip = 0){
  
  files_exp <- vector_of_files
  # print(files_exp)
  #Combine the data itself into one dataframe
  exp = lapply(files_exp, 
               read.delim, 
               skip = read_skip) %>% 
    purrr::reduce(left_join, 
                  by = 'Geneid')
  #Using purrr and left_join means that Geneid will have to match between the samples so I removed the test for this.
  
  return(exp)
}
```

```{r function_counttable_to_tpm}

counttable_to_tpm = function(count_table,
                             table_names,
                             transcript_lengths = chabaudi_transcript_lengths,
                             technical_reps = FALSE,
                             experiment_name = NULL){
  
  #Before assigning stage numbers we need to merge the technical replicates
  
  if(technical_reps == TRUE){
    
    if(all(!grepl(colnames(table_names), pattern = 'Technical_Replicates'))){
      stop('If technical_reps is TRUE then the table_names data frame must have a Technical_Replicates column')
    }
    
    geneid_col = count_table[,'Geneid', drop = FALSE]
    list_techreps = lapply(unique(table_names$Technical_Replicates), function(techrep){
      print(techrep)
      #For each technical replicate we need the mean of the counts
      # So get the count table for these replicates - Alias names haven't been assigned yet so names should be runs
      techrep_runs = filter(table_names, Technical_Replicates == paste(techrep)) %>% 
        `$`(Run)
      #Extract the counts and calculate the mean
      techrep_counts =  select(count_table, paste(techrep_runs)) %>% 
        apply(1, mean) %>% data.frame()
      colnames(techrep_counts) = paste(techrep)
      techrep_counts
    })
    
    exp = bind_cols(geneid_col, list_techreps)
    colnames(exp)[-1] = table_names$Alias[match(colnames(exp)[-1], table_names$Technical_Replicates)]
    
  }else{
    
    exp = count_table
    colnames(exp)[-1] = as.character(table_names$Alias[match(colnames(exp)[-1], table_names$Run)])
    
  }
  
  #Need a number for each sample based on the number of distinct samples for each stage
  #Also going to remove NA columns here as they are things we don't want.
  
  colnames(exp) <- ifelse(!is.na(colnames(exp)), 
                          uniquify(colnames(exp)), 
                          NA)
  exp <- exp[,!is.na(colnames(exp)),drop = FALSE]
  
  
  # print(colnames(exp))
  exp = exp %>% arrange(Geneid)
  
  #Calculate the tpm
  tpm_exp = tpm(exp, transcript_lengths)
  
  list_exp =  list(counts = exp, tpm = tpm_exp, experiment = experiment_name)
  return(list_exp)
}
```

# Downloading the count files

This part is long not because downloading the count files is tricky but because the names of the different samples ought to be standardised as much as possible to be helpful down the line.

Count data was generated on the Crick HPC from the fq.gz files between 
using Nextflow:

Using PlasmoDB v45 _P. chabaudi chabaudi_ genome.

Here I have written a function which can help with re-naming columns and removing those you don't need if the different stages expected and the vector of files/list of objects containing the counts are specified. The function returns a list containing the count and the TPM files.

The design table from online is missing a file ('21659_8#24') for some reason. This has been designated as 'MT_Unknown' until we can find out which one it is. I've actually decided to remove this.

```{r download_files}
#Use the rMT stage differential count in order to name the samples, but keep time to retain order
times_stages_table <- data.frame(time = c('02h', '05h', '08h', '11h', '14h', '17h','20h','23h'),
                                 stage_diff_count = c('Late-Rings',
                                                      'Rings-Troph-conversion',
                                                      'Early-Trophs',
                                                      'Mid-Trophs',
                                                      'Late-Trophs',
                                                      'Early-Rings',
                                                      'Early-Mid-Rings',
                                                      'Late-Mid-Rings'))
# R will convert the dashes to '.' at some point so let's have this notation here also
times_stages_table$r_stage_diff_count <- str_replace_all(times_stages_table$stage_diff_count, 
                                                         pattern = '-', 
                                                         replacement = '\\.')

design_table <- read.delim('samples_lanes.list',
                           sep = '\t',
                           header = FALSE,
                           col.names = c('sample', 'transmission', 'sequence'),
                           stringsAsFactors = FALSE) %>% 
  #regex extract for the numbers (one or more) before am, pm or h, or just an 'sch' for schizont
  mutate(time = str_extract(sample, pattern = '[:digit:]+([ap]m|h)|sch')) %>% 
  #Convert the times given in 'h' to robustly coded times in 24h clock
  mutate(time = ifelse(grepl(time, pattern = '[[:digit:]]h$'), 
                       strptime(time, format="%Hh") %>% format(., "%Hh"),
                       time)) %>% 
  mutate(time = ifelse(grepl(time, pattern = '[[:digit:]](a|p)m'), 
                       strptime(time, format="%I%p") %>% format(., "%Hh"),
                       time)) %>% 
  mutate(Alias = paste0(transmission, '_', time)) %>% 
  #Paste on the stage from the diff count, or nothing if NA
  mutate(Alias = ifelse(is.na(match(time,
                                    times_stages_table$time)),
                        Alias,
                        paste0(Alias, '_', 
                               times_stages_table$stage_diff_count[match(time,
                                                                         times_stages_table$time)]))) %>% 
  mutate(Alias = gsub(Alias, pattern = 'MT', replacement = 'rMT')) %>% 
  mutate(Alias = ifelse(grepl(Alias, pattern = 'sch'), paste0(Alias, '.culture'), Alias)) %>% 
  #To make the names R compatible
  mutate(Alias = make.names(Alias)) %>% 
  mutate(sequence = gsub(sequence, 
                         pattern = '9478_[[:digit:]]', 
                         replacement = '9478_cat'))

#Get vector of the files of MT and merged SBP
# the merged SBP files are not separated into _3 and _4

unknown_sample <- data.frame(sample = 'PcUnknown', 
                             transmission = 'rMT',
                             time = 'Unknown',
                             sequence = '21659_8#24',
                             Alias = 'rMT_Unknown')
design_table <- bind_rows(design_table, unknown_sample)

# design_table %>% 
#   group_by(Alias) %>% 
#   dplyr::summarise(n())

# design_table %>% 
#   group_by(transmission) %>% 
#   dplyr::summarise(n())

#Old files
# vector_of_files <- list.files(pattern = 'txt$') %>% str_subset(pattern = '21659|9478_#')

#New files - methods needs updating
vector_of_files <- c(
  list.files('nextflow_working_dir_PlasmoDBv48_rna-seq-r1.4.2_dir/featureCounts/gene_counts',
             pattern = 'txt$',
             full.names = TRUE)
)

# length(vector_of_files)
# length(tmp)

# str_extract(tmp, pattern = '(21659|9478)_([[:digit:]]+|cat|)#[[:digit:]]+')
# str_extract(vector_of_files, pattern = '(21659|9478)_([[:digit:]]+|cat|)#[[:digit:]]+')

# tmp[tmp %in% vector_of_files]

twentyfour_counts <- featurecounts_to_table(vector_of_files = vector_of_files,
                                            read_skip = 1)


#The names of the files / Runs is now a bit longer thanks to my method of naming files
design_table$Run <- unlist(
  sapply(make.names(design_table$sequence), 
                            function(nam){str_subset(colnames(twentyfour_counts)[-1], 
                                                     pattern = paste0(paste(nam), '_'))})
  ) %>% 
  make.names() #Make names acts during read.delim in the next function

design_table$unique_alias <- uniquify(design_table$Alias, first_one = TRUE)
# disagree(list(colnames(twentyfour_counts), design_table$Run))
```

```{r}
#Getting a nice count table for the paper and Github
chab_count_table <- select(twentyfour_counts, 
       matches('Geneid|bam')) %>% 
  rename_with(function(colnam){
    design_table$unique_alias[match(colnam, design_table$Run)]
  },
  matches('bam')) %>% 
  select(-matches('sch|Unk|SBP')) %>% 
  .[sort(colnames(.))] %>% 
  arrange(Geneid)

write_xlsx(chab_count_table,
           'Manuscript_SuppInfo_chabaudi_24h_counts.xlsx')
write.csv(chab_count_table,
           'Manuscript_SuppInfo_chabaudi_24h_counts.csv')

# tpm(chab_count_table, 
#     lengths = chabaudi_transcript_lengths)

```

New list of sequence files has 9478_(3 or 4)_#(Number) while the old files just had 9478_#(Number). This appears to be the cause of discrepency. Why are there these extra files?? I wonder if they are paired files which weren't analysed together? - Issue was because I hadn't merged technical replicates.

```{r calculate_save_TPM}
# #Calculate and save TPM
# twentyfour_ct <- counttable_to_tpm(count_table = twentyfour_counts,
#                                   table_names = design_table,
#                                   experiment_name = NULL)
# # There's an issue with bind_cols in this function at the moment
# #
# # #saving this output
# write_csv(twentyfour_ct$tpm,
#           'tl19-07_twentyfour_tpm_samples.csv')
# write_csv(twentyfour_ct$counts,
#           'tl19-07_twentyfour_counts_samples.csv')
# 
# #Getting all the sample columns in order.
# twentyfour_tpm_sbp <- twentyfour_ct$tpm %>%
#   # select(-rMT_Unknown) %>%
#   select_at(vars(matches('Geneid|SBP_')))
# 
# twentyfour_tpm_sbp <- select(
#   twentyfour_tpm_sbp,
#   Geneid,
#   ordering(
#     colnames(twentyfour_tpm_sbp)[-1],
#     order_vector = order_vector
#   )
# )
# # Saving a tab-delimited file
# write_delim(twentyfour_tpm_sbp,
#             'tl19-07_twentyfour_tpm_samples_SBP.txt',
#             delim = '\t')
# 
# twentyfour_tpm_rMT <- twentyfour_ct$tpm %>%
#   select(-rMT_Unknown) %>%
#   select_at(vars(matches('Geneid|rMT_')))
# 
# twentyfour_tpm_rMT <- select(
#   twentyfour_tpm_rMT,
#   Geneid,
#   ordering(
#     colnames(twentyfour_tpm_rMT)[-1],
#     order_vector = order_vector
#   )
# )
# # Saving a tab-delimited file
# write_delim(twentyfour_tpm_rMT,
#             'tl19-07_twentyfour_tpm_samples_rMT.txt',
#             delim = '\t')

```

```{r read_tpm}

#Read TPM - no unknown - combined data frame
twentyfour_ct_comb <- list(
  tpm = read_csv('tl19-07_twentyfour_tpm_samples.csv') %>% 
    select(-rMT_Unknown),
  counts = read_csv('tl19-07_twentyfour_counts_samples.csv') %>% 
    select(-rMT_Unknown)
)

#Save counts

write_xlsx(twentyfour_ct_comb$counts[,sort(colnames(twentyfour_ct_comb$counts))] %>% 
             dplyr::select(!matches('sch')),
           'Manuscript_Frontiers_chabaudi_24h_counts.xlsx')

#Read TPM separately - no unknown
twentyfour_ct_rMT <- list(
  tpm = read_csv('tl19-07_twentyfour_tpm_samples.csv') %>% 
    select(-rMT_Unknown) %>%
    select_at(vars(matches('Geneid|rMT_'))),
  counts = read_csv('tl19-07_twentyfour_counts_samples.csv') %>% 
    select(-rMT_Unknown) %>%
    select_at(vars(matches('Geneid|rMT_'))),
  experiment = 'rMT')

twentyfour_ct_SBP <- list(
  tpm = read_csv('tl19-07_twentyfour_tpm_samples.csv') %>% 
                        select(-rMT_Unknown) %>%
                        select_at(vars(matches('Geneid|SBP_'))),
  counts = read_csv('tl19-07_twentyfour_counts_samples.csv') %>% 
                        select(-rMT_Unknown) %>%
                        select_at(vars(matches('Geneid|SBP_'))),
  experiment = 'SBP')
       
twentyfour_ct <- list(twentyfour_ct_rMT, 
                      twentyfour_ct_SBP)

#Removing the rMT and SBP prefix for the experiments now that they're separated by transmission
twentyfour_ct <- lapply(twentyfour_ct, 
                        function(list_ct){
                          lapply(list_ct, 
                                 function(ct){
                                   if(!is.null(colnames(ct))){
                                     colnames(ct) <- str_remove(colnames(ct),
                                                                pattern = '(rMT|SBP)_')
                                   }
                                   return(ct)
                                 })
                        })

```

```{r counts_v_features}
num_counts <- apply(twentyfour_ct_comb$counts[,-1], 2, sum)
num_features <- apply(twentyfour_ct_comb$counts[,-1], 2, function(x) sum(x > 0))
plot(num_counts, num_features 
     #, ylim = c(0, max(num_features))
     )
```


```{r sanity_test}

#sanity test
# twentyfour_ct$tpm %>% select(Geneid, 'SBP_17h_3') %>% .[450:455,]
# # read.delim('samples_lanes.list',
# #                            sep = '\t',
# #                            header = FALSE,
# #                            col.names = c('sample', 'transmission', 'sequence'),
# #                            stringsAsFactors = FALSE)
# read.delim(header = TRUE, sep = '\t', file = list.files(pattern = '9478_#6')[1], skip = 1) %>% 
#   arrange(Geneid) %>% 
#   select(Geneid, X9478_.6_hisat2alignment_v45chabaudigenome.sorted.merged.bam) %>% .[450:455,]
# 
# twentyfour_ct$counts %>% select(Geneid, 'MT_05h_3') %>% .[1284:1289,]
# read.delim(header = TRUE, sep = '\t', file = list.files(pattern = '21659_8#3')[1], skip = 1) %>% 
#   arrange(Geneid) %>% 
#   select(Geneid, X21659_8.3_hisat2alignment_v45chabaudigenome.sam) %>% .[1284:1289,]

```

# Hierarchical clustering of the samples

```{r hclusts}
hclusts = function(tpms){
  dists = dist(t(tpms$tpm[,-1]))
  plot(hclust(dists), 
       cex = 0.7, 
       main = tpms$experiment)
}

invisible(
  lapply(twentyfour_ct, hclusts)
)
# hclusts(twentyfour_ct_comb)
```

Using scale() to normalise the data variance and then hclust with 'average' method. The rMT samples and SBP samples still cluster separately.

```{r hclusts_scaled_data}
hclusts_scaled = function(tpm){
  dists = dist(t(scale(tpm$tpm[,-1])))
  plot(hclust(dists, method = 'average'), cex = 0.7)
}
hclusts_scaled(twentyfour_ct_comb)
```


Both here and in the correlation plots below most of the samples (except 11 and 14h) are distinct based not on time of day but be method of transmission. This isn't what one would expect. It of course could be due to batch effects since the SBP and MT experiments were done by different people in different years.

hclust without that one naughty pseudogene. This one pseudogene, PCHAS_0420800, is a major defining gene of the rMT samples, and removal of this gene makes the samples cluster as we'd expect; by asexual stage and not by transmission 

```{r hclust_nopseudo}
tpm_nopseudo <- twentyfour_ct_comb$tpm %>% filter(!Geneid %in% 'PCHAS_0420800')

# sapply(tpm_nopseudo[,-1], sum)[rev(order(sapply(tpm_nopseudo[,-1], sum)))]
# Need to rescale the TPM

tpm_nopseudo_rescale <- lapply(colnames(tpm_nopseudo), 
                               function(column_name){
                                 column <- getElement(tpm_nopseudo, paste(column_name))
                                 if(is.numeric(column)){
                                   #is.numeric to avoid trying to scale the Geneid column
                                   tpm_scale_factor <- 1e6 / sum(column)
                                   tpm_scaled <- as.numeric(column*tpm_scale_factor)
                                 }else{
                                   tpm_scaled <- column
                                 }
                                 return(tpm_scaled)
                               }) %>% 
  bind_cols

colnames(tpm_nopseudo_rescale) <- colnames(tpm_nopseudo)
# sapply(tpm_nopseudo_rescale[,-1], sum)[rev(order(sapply(tpm_nopseudo_rescale[,-1], sum)))]

#Note now the MT samples can be distinguished by having a lower total TPM
dists = dist(t(tpm_nopseudo_rescale[,-1]))
plot(hclust(dists), cex = 0.7)
```

# Density plots

These graphs show the distribution of TPM values for each gene in each sample. The shapes of the curves follow the generally expected pattern of one smaller peak at zero and another peak and higher values with a long tail. Individual samples however show a lot of variation from one another presumably because of differences in the amount of sequences detected by the experiments.

```{r density_plots, fig.show="hold", out.width="50%"}
#fig.show and out.width settings for having both plots on same output.
list_min = lapply(twentyfour_ct, function(input){
  input_tpm = input$tpm
  minima = sapply(colnames(select(input_tpm, -Geneid)), function(colnam){
    #Want to exclude the weird sporozoite densities
    if(grepl(colnam, pattern = 'sporozoite', ignore.case = TRUE)){
      NA
    }else{
      tpms = select(input_tpm, paste(colnam)) %>% unlist %>% as.numeric()
      den = density(log1p(tpms))
      #Get the difference between adjacent y values, find the positive change, first one coresponds to the first minimum
      first_min = den$x[which(diff(sign(diff(den$y)))==2)] %>% .[1]
    }
  }) %>% expm1()
  #expm1 is the reverse of log1p - almost forgot to take away the one!
  list(experiment = input$experiment,
       range = range(minima, na.rm = TRUE), 
       mean = mean(minima, na.rm = TRUE),
       median = median(minima, na.rm = TRUE))
})

min_median = median(unlist(lapply(list_min, function(x) x$median)))
min_min = min(unlist(lapply(list_min, function(x) x$range)))
min_max = max(unlist(lapply(list_min, function(x) x$range)))

threshold <- min_median

# print(min_median)

list_bw = lapply(twentyfour_ct, function(expt){ 
  lapply(colnames(expt$tpm)[-1], function(sample){
    data = as.numeric(unlist(select(expt$tpm, paste(sample))))
    dens = density(log1p(data))
    dens$bw
})
});
bw_mean = mean(unlist(list_bw))
bw_range = max(unlist(unlist(list_bw))) - min(unlist(unlist(list_bw)))
# print(paste('Bandwidth range = ', bw_range))

invisible(
  lapply(twentyfour_ct, 
       density_samples, 
       save = FALSE)
)
#Wrapping in Invisible to hide the console output of NULL (I don't know where it comes from...)
```

Based on these density plots we make the assumption of a threshold of expression as being `r round(min_median, digits = 2)` TPM.

# Top general and _cir_ genes in each stage

```{r top_genes}
top_n_genes = function(tpm_input,
                       threshold = 0,
                       stage_str_extract_regex_pattern = '(?<=_).+(?=_[[:digit:]]+)|sch.culture'){
  tpm = tpm_input$tpm %>% 
    #Melt the data frame for using dplyr
    melt(id.vars = 'Geneid', 
         variable.name = 'sample', 
         value.name = 'tpm') %>% 
    mutate(stage = str_extract(sample, 
                               pattern = paste(stage_str_extract_regex_pattern))) %>% 
    group_by(Geneid, stage) %>%  
    dplyr::summarise(median_tpm = median(tpm),
                     mean_tpm = mean(tpm), 
                     min_tpm = min(tpm), 
                     max_tpm = max(tpm), 
                     sd_tpm = sd(tpm)) %>% 
    group_by(stage) %>% 
    mutate(experiment = tpm_input$experiment)
  
  list_data = list('tpm' = tpm,
                   'experiment' = tpm_input$experiment)
  return(list_data)
}

### Generate and save the top gene data

# twentyfour_top <- lapply(twentyfour_ct, top_n_genes)
# 
# lapply(twentyfour_top, function(transmission_top){
#   tpm_data <- transmission_top$tpm
#   write_csv(tpm_data,
#             paste0('tl19-07_twentyfour_tpm_samplescollated_longform_',
#                    transmission_top$experiment,
#                    '.csv'))
# })
# 
# twentyfour_top_comb <- top_n_genes(twentyfour_ct_comb,
#                                    stage_str_extract_regex_pattern = '.+(?=_[[:digit:]]+)')
# 
# write_csv(twentyfour_top_comb$tpm,
#           'tl19-07_twentyfour_tpm_samplescollated_longform.csv')

###

### Read in the top gene data

twentyfour_top <- lapply(list.files(pattern = 'tl19-07_twentyfour_tpm_samplescollated_longform_', 
                  full.names = TRUE), 
       function(top_files){
         list(
           tpm = read_csv(top_files),
              experiment = str_extract(top_files, pattern = 'rMT|SBP')
         )
       })

twentyfour_top_comb <- list(tpm = read_csv('tl19-07_twentyfour_tpm_samplescollated_longform.csv'))

###
```

```{r kable_table_top_n_genes, results = "asis"}

top_n_genes_kable_table <- function(top_n_tpm,
                                    n_top = 5,
                                    subset_genes = NULL,
                                    subset_genes_title = 'all',
                                    gene_info = chabaudi_gene_info,
                                    highlight_genes_regex = 'PCHAS_0101200'){
  # top_n_tpm <- twentyfour_top[[1]]
  
  tpm <- top_n_tpm$tpm
  
  #Calculating the index used to make the kable table
  
  kable_index = rep(n_top, 
                    times = length(unique(tpm$stage)))
  names(kable_index) = unique(tpm$stage)

  if(is.null(subset_genes)){
    top_genes <- tpm
  }else{
    top_genes <- filter(tpm, Geneid %in% subset_genes)
  }
  
  top_genes = top_genes %>% 
    group_by(stage) %>% 
    top_n(wt = median_tpm, 
          n = n_top) %>% 
    dplyr::arrange(stage, 
                   desc(median_tpm)) %>% 
    mutate_if(is.numeric, 
              function(x){round(x, 
                                digits = 2)})
  
  top_genes$description = gene_info$handy_descriptions[match(top_genes$Geneid, 
                                                             gene_info$Geneid)]
  
  top_genes_kable <- top_genes %>% 
    mutate(median_tpm = cell_spec(median_tpm, "html", 
                                  color = ifelse(median_tpm > 10, "red", "blue"))) %>% 
    mutate(Geneid = as.character(Geneid)) %>% 
    mutate(Geneid = ifelse(grepl(Geneid, pattern = paste(highlight_genes_regex)),
                           cell_spec(Geneid, bold = TRUE),
                           Geneid)) %>% 
    kable(format = 'html', 
          caption = paste0(top_n_tpm$experiment, 
                           ' - Top ', 
                           paste(n_top), 
                           ' expressed ',
                           paste(subset_genes_title),
                           ' genes'), 
          escape = FALSE) %>%
    kable_styling() %>%
    pack_rows(index = kable_index) %>%
    scroll_box(width = "100%", height = "500px")
  
  return(top_genes_kable) 
}

lapply(twentyfour_top, 
       top_n_genes_kable_table)
lapply(twentyfour_top,
       top_n_genes_kable_table,
       subset_genes = cir_id, 
       subset_genes_title = 'cir')

```

~~At the moment these tables are not showing up in this document...~~

Wow! The SBP cir PCHAS_1100300 isn't expressed higher than ancestral or rodent-conserved pir-like in these SBP samples...

For all the other genes again in MT one of the highest expressed genes is a pseudogene while in SBP it is a series of ETRAMPs (although MT expresses these also it seems).

```{r most_variable_genes, eval = FALSE}
twentyfour_top$tpm %>%
  top_n(5, sd_tpm) %>%
  arrange(stage, desc(sd_tpm))
```

* _PCHAS_0101200_ = ancestral cir.

* _PCHAS_0524800_ = rodent conserved cir-like genes.

* _PCHAS_1100300_ = SBP-dominant cir gene (Spence et al, 2013).

```{r main-three-pir_heatmap}
# pdf('tl19-07_cirgenes_24h_heatmap.pdf', width = 10, height = 5)
draw_heatmap_chabaudi_24h(datasets =twentyfour_ct, 
                          genelist = c('PCHAS_0101200',
                                       # 'PCHAS_0524800',
                                       'PCHAS_1100300'),
                          scale = 'max',
                          threshold = 0,
                          log_it = TRUE)
# dev.off()
twentyfour_ct_comb$tpm %>% 
  filter(Geneid %in% c('PCHAS_0101200',
                       # 'PCHAS_0524800',
                       'PCHAS_1100300')) %>% 
  kable() %>% 
  kable_styling() %>% 
  scroll_box(width = "100%")
```

```{r Deirdres CHAPLs, eval = FALSE}
protein <- c('PCHAS_0400300',   
             'PCHAS_0600600',    
             'PCHAS_1200500',    
             'PCHAS_1300101',
             'PCHAS_0101200',   
             'PCHAS_1100300',
             'PCHAS_0626900')

draw_heatmap_chabaudi_24h(datasets = twentyfour_ct, 
                          genelist = protein,
                          scale = 'max',
                          threshold = 0,
                          log_it = TRUE,
                          gene_names_for_title = 'Available protein')

chapl <- c('PCHAS_0626200',
           'PCHAS_0626700',
           'PCHAS_0627100') 

draw_heatmap_chabaudi_24h(datasets = twentyfour_ct, 
                          genelist = chapl,
                          scale = 'max',
                          threshold = 0,
                          log_it = FALSE,
                          gene_names_for_title = 'Deirdre\'s ChAPLs')

available_primers <- c('PCHAS_0600600',
                       'PCHAS_1100300',
                       'PCHAS_1301700',
                       'PCHAS_0400300',
                       'PCHAS_0301400',
                       'PCHAS_1200500',
                       'PCHAS_1300101')

draw_heatmap_chabaudi_24h(datasets = twentyfour_ct, 
                          genelist = available_primers,
                          scale = 'max',
                          threshold = 0,
                          log_it = FALSE,
                          gene_names_for_title = 'Available primers')
```

Good _cir_ negative controls would be 0600600 and 1200500 for SBP and 1301700 for both (but especially MT).

# Correlation plots {.tabset}

## Correlation plot of collated stages (all genes)

```{r corelation_plots_collated}
# Collated across the stages for a more easily understood heatmap

big_top_twentyfour = twentyfour_ct_comb$tpm %>% 
  melt(id.vars = 'Geneid', variable.name = 'sample', value.name = 'tpm') %>% 
  mutate(stage = gsub(sample, pattern = '_[[:digit:]]$', replacement = '')) %>% 
  group_by(Geneid, stage) %>% 
  dplyr::summarise(median_tpm = median(tpm)) %>% 
  dcast(Geneid ~ stage)

big_top_twentyfour_mat = big_top_twentyfour[,-1,drop=FALSE]

# pdf(file = 'tl19-07_corrplot_24h_rnaseq_chabaudi.pdf')
corrplot(cor(big_top_twentyfour_mat), method = 'color', order = 'hclust', cl.lim = c(-0,1), tl.cex = 0.7,
         col = c(viridis(100), magma(115)), 
         mar=c(0,0,1,0),
         title = 'Correlation plot')
# dev.off()

```

## Correlation plot of collated stages (only _cir_ genes)

```{r}

#SBP now all together, so the schizonts were pushing them elsewhere

#Now just the cir genes

big_top_twentyfour_cir_mat = big_top_twentyfour %>% 
  filter(Geneid %in% cir_id) %>% 
  select(-Geneid)
corrplot(cor(big_top_twentyfour_cir_mat), method = 'color', order = 'hclust', 
         cl.lim = c(0.0,1), tl.cex = 0.7,
         col = c(viridis(100), magma(100)), 
         mar=c(0,0,1,0),
         title = 'Correlation plot (only cirs)')
```

## Correlation plot of collated stages, but without schizonts (all genes)

```{r correlation_collated_nosch}

#How does this order with the schizonts removed

big_top_twentyfour_nosch = big_top_twentyfour %>% select(-rMT_sch.culture)

big_top_twentyfour_nosch_mat = big_top_twentyfour_nosch[,-1,drop=FALSE]

# pdf(file = 'tl19-07_corrplot_24h_rnaseq_chabaudi_noschz.pdf')
corrplot(cor(big_top_twentyfour_nosch_mat), method = 'color', order = 'hclust', cl.lim = c(0,1), tl.cex = 0.7,
         col = c(viridis(100), magma(115)), 
         mar=c(0,0,1,0),
         title = 'Correlation plot (no schizont samples)')
# dev.off()
```

Now all the SBP and MT groups cluster together

## Correlation plot of all samples (all genes)

```{r correlation_plot}
twentyfour_tpm_mat = twentyfour_ct_comb$tpm
rownames(twentyfour_tpm_mat) = twentyfour_tpm_mat$Geneid
twentyfour_tpm_mat = twentyfour_tpm_mat[,-1,drop=FALSE] 

#Replicates
twentyfour_all_cor = cor(twentyfour_tpm_mat)
corrplot(twentyfour_all_cor, tl.cex = 0.5, mar=c(0,0,1,0),
         method = 'color', order = 'hclust', cl.lim = c(0,1), col = c(viridis(100), tl.cex = 0.7, magma(115)),
         title = 'Correlation plot - individual samples')
#MT and SBP separate, SBP 11/14/17h match MT schizonts
```

## Correlation plot of all samples (but only _cir_ genes)

```{r cir_correlation}

#Replicate cirs
twentyfour_tpm_mat_cir <- filter(twentyfour_ct_comb$tpm, Geneid %in% cir_id) #This drops the rownames for some reason
rownames(twentyfour_tpm_mat_cir) <- twentyfour_tpm_mat_cir$Geneid 
twentyfour_tpm_mat_cir <- twentyfour_tpm_mat_cir[,-1,drop=FALSE]
twentyfour_tpm_mat_cir_cor <- cor(twentyfour_tpm_mat_cir)
corrplot(twentyfour_tpm_mat_cir_cor, tl.cex = 0.5, method = 'color', order = 'hclust', 
         cl.lim = c(0,1), col = c(viridis(100), magma(115)),
         mar=c(0,0,1,0),
         title = 'Correlation plot - individual samples (only cirs)')
```

## Do the top 10 expressed genes in each sample give any extra clarity to the correlation plot?

Drawing a correlation plot with only the top 10 expressed genes in the samples.

Not really, I guess need to get the genes with the highest variance not total score.

```{r top10genes}
top10genes <- twentyfour_top_comb$tpm %>% 
  dplyr::arrange(desc(median_tpm)) %>% 
  group_by(stage) %>% 
  top_n(median_tpm, n = 10) %>% 
  .$Geneid %>% 
  unique

draw_heatmap_chabaudi_24h(datasets = twentyfour_ct, 
                          genelist = top10genes,
                          scale = 'max',
                          threshold = 0,
                          log_it = TRUE)

big_top_twentyfour_10_mat = big_top_twentyfour %>% 
  filter(Geneid %in% cir_id) %>% 
  select(-Geneid)
corrplot(cor(big_top_twentyfour_10_mat), method = 'color', order = 'hclust', cl.lim = c(0.0,1), tl.cex = 0.7,
         col = c(viridis(100), magma(100)))
```

## Do the top 10 most variable genes across the samples give any extra clarity to the correlation plot?

The top ten most variable genes (highest standard deviation) between all the individual samples were identified.

Did with and without the pseodogene _PCHAS_0420800_ which dominates the expression profile of MT and not SBP.

```{r most_variable_genes_corr}

variable_genes <- twentyfour_top_comb$tpm %>% 
  ungroup %>% 
  group_by(Geneid) %>% 
  dplyr::summarise(med_tpm = median(median_tpm),
                   std_tpm = sd(median_tpm)) %>% 
  mutate(product_description = 
           chabaudi_gene_info$Product.Description[match(Geneid, chabaudi_gene_info$Gene.ID)]) %>% 
  arrange(desc(std_tpm))

variable_gene_names <- variable_genes$Geneid[1:10]

draw_heatmap_chabaudi_24h(datasets = twentyfour_ct, 
                          genelist = variable_gene_names,
                          scale = 'max',
                          threshold = 0,
                          log_it = TRUE)

big_top_twentyfour_mostvar_mat = big_top_twentyfour %>% 
  filter(Geneid %in% variable_gene_names) %>% 
  select(-Geneid)
corrplot(cor(big_top_twentyfour_mostvar_mat), method = 'color', order = 'hclust', tl.cex = 0.7,
         col = c(magma(200)), title = '10 most variable genes', mar = c(0,0,1,0))
#Note that the scale now extends to -1

#Again but without the pseudogene

variable_gene_names_notop <- variable_genes$Geneid[2:11]
big_top_twentyfour_mostvar_mat = big_top_twentyfour %>% 
  filter(Geneid %in% variable_gene_names_notop) %>% 
  select(-Geneid)
corrplot(cor(big_top_twentyfour_mostvar_mat), method = 'color', order = 'hclust', tl.cex = 0.7,
         col = c(magma(200)), title = '10 most variable genes - except pseudo', mar = c(0,0,1,0))

```

# Undetected _cir_ genes.

Which _cir_ genes are never expressed over the threshold of `r round(min_median, digits = 2)` TPM.

```{r never_expressed}
filter_at(twentyfour_ct_comb$tpm, 
          vars(-contains('Geneid')), 
          all_vars(. < min_median)) %>% 
  filter(Geneid %in% cir_id) %>% 
  kable() %>% 
  kable_styling() %>% 
  scroll_box(width = "100%", height = "500px")
```


# PCA of the life stages {.tabset}

## PCA with all genes {.tabset}

### 2D plot of PC1 v PC2

```{r pca_calculation, results = TRUE}
twentyfour_tpm <- twentyfour_ct_comb$tpm
rownames_geneid <- twentyfour_tpm$Geneid
twentyfour_tpm_forpca <- select(twentyfour_tpm, -Geneid)
rownames(twentyfour_tpm_forpca) <- rownames_geneid
twentyfour_tpm_pca <- prcomp(twentyfour_tpm_forpca, center = TRUE, scale. = TRUE)
#Need to look into what exactly scale and center are doing
```

```{r 2d_pca, results = TRUE}
twentyfour_tpm_pca_var <- get_pca_var(twentyfour_tpm_pca)
twentyfour_tpm_pca_coords <- data.frame(twentyfour_tpm_pca_var$coord)

twentyfour_tpm_pca_coords <- data.frame(sample = rownames(twentyfour_tpm_pca_var$coord),
                                        PC1 = twentyfour_tpm_pca_coords$Dim.1,
                                        PC3 = twentyfour_tpm_pca_coords$Dim.3,
                                        PC2 = twentyfour_tpm_pca_coords$Dim.2) %>% 
  dplyr::mutate(stage = gsub(sample, pattern = '_[[:digit:]]$', replacement = '')) %>% 
  dplyr::mutate(time = str_split_fixed(stage, pattern = '_', n = 2)[,2]) %>% 
  dplyr::mutate(transmission = str_split_fixed(sample, pattern = '_', n = 3)[,1])

# colornames <- c(cbPalette, 'black', 'red')
colornames <- viridis(length(unique(twentyfour_tpm_pca_coords$time)))
colornames <- setNames(colornames, 
                       sort(unique(twentyfour_tpm_pca_coords$time)))

pca_importance <- as.data.frame(summary(twentyfour_tpm_pca)$importance)
pc1_importance <- round(pca_importance$PC1[2]*100, digits = 1)
pc2_importance <- round(pca_importance$PC2[2]*100, digits = 1)
pc3_importance <- round(pca_importance$PC3[2]*100, digits = 1)

pl <- plot_ly(twentyfour_tpm_pca_coords, 
             x  = ~PC1, y = ~PC2,
             type = 'scatter', mode = 'markers',
             color = ~time, text = ~sample,
             colors = colornames,
             # size = ~total_features,
             marker = list(opacity = 1, size = 16),
             symbol = ~transmission, symbols = c('circle','x')) %>% 
  layout(xaxis = list(title = paste0('PC1 ',pc1_importance,'%')),
         yaxis = list(title = paste0('PC2 ',pc2_importance,'%')),
         legend = list(font = list(size = 8)))
pl
orca(pl, "tl19-07_audreybrugat24hchabaudi_2D-PCA.pdf")

head(twentyfour_tpm_pca$x[rev(order(abs(twentyfour_tpm_pca$x[,1]))),,drop=FALSE])[,1:9]
```

```{r 2d_pca_allgenes_suppfig}
(
  plot <- ggplot(twentyfour_tpm_pca_coords,
                 aes(
                   x = PC1,
                   y = PC2,
                   col = time,
                   shape = transmission
                 )) +
    geom_point(size = 3,
               alpha = 0.8) +
    scale_color_manual(values = colornames) +
    scale_shape_manual(
      values = setNames(
        c(17,19),
        unique(twentyfour_tpm_pca_coords$transmission)
      )
    ) +
    xlab(paste0('PC1 ', round(pca_importance$PC1[2]*100, digits = 1),'%')) +
    ylab(paste0('PC2 ', round(pca_importance$PC2[2]*100, digits = 1),'%')) +
    guides(shape=guide_legend(ncol=2),
           col = guide_legend(ncol=2)) +
    theme_classic() +
    theme(legend.key.size = unit(4, 'mm'),
          legend.text = element_text(size = 7))
)
ggsave2(filename = 'tl19-07_chabaudi24h_supp_figure_pca_allgenes.png',
        plot = plot,
        dpi = 300,
        width = 15,
        height = 10,
        units = 'cm')
```


Can do a plot of the gene loadings for PC1 and PC2 to see which genes are having the biggest impact on each. 

```{r 2d_pca_loadings}
# plot_ly(data.frame(Geneid = rownames(twentyfour_tpm_pca$x),
#                    product = chabaudi_gene_info$Product.Description[match(rownames(twentyfour_tpm_pca$x), 
#                                                          chabaudi_gene_info$Gene.ID)],
#                    twentyfour_tpm_pca$x),
#         x = ~PC1, y = ~PC2,
#         type = 'scatter', mode = 'markers',
#         text = ~paste(Geneid, product))
plot_ly_biplot(twentyfour_tpm_pca,
               prin_components = c(1,2,3),
               scale.loads = 700,
               separate_multigene = FALSE,
               three_dimensions = FALSE,
               textposition = "top left",
               gene_info = chabaudi_gene_info)
orca(plot_ly_biplot(twentyfour_tpm_pca,
               prin_components = c(1,2,3),
               scale.loads = 700,
               separate_multigene = FALSE,
               three_dimensions = FALSE,
               textposition = "top left",
               gene_info = chabaudi_gene_info),
     "tl19-07_audreybrugat24hchabaudi_biplotPCA.pdf")

```

Negative loading for the the PCHAS_0420800 gene means that the samples which contain it are pushed into the positive of the PComponent. The absolute value is what's important loadings.

Most obvious separation is by method of transmission and not by time of day.

```{r pca_loading_genes}
top_loadings_pc1 <- twentyfour_tpm_pca$x[rev(order(abs(twentyfour_tpm_pca$x[,1]))),,drop=FALSE][1:5,1:8]
top_loadings_pc1_genes <- rownames(top_loadings_pc1)
chabaudi_gene_info %>% filter(Geneid %in% top_loadings_pc1_genes)

pdf('tl19-07_24hchabaudi_heatmap_topPCAloadingsgenes.pdf',width = 7, height = 5)
draw_heatmap_chabaudi_24h(tpm_input = twentyfour_ct_comb, 
                          genelist= top_loadings_pc1_genes,
                          scale = 'max',
                          log_it = TRUE)
dev.off()
```


### 3D plot of PC1 v PC2 v PC3

```{r 3d_pca, results = TRUE}

q <- plot_ly(twentyfour_tpm_pca_coords, 
             x  = ~PC1, y = ~PC2, z = ~PC3,  mode = 'markers',
             type = 'scatter3d', color = ~time, text = ~sample,
             colors = colornames,
             # size = ~total_features,
             marker = list(opacity = 1, size = 5),
             symbol = ~transmission, symbols = c('circle','x')) %>% 
  layout(scene = list(xaxis = list(title = paste0('PC1 ',pc1_importance,'%')),
                      yaxis = list(title = paste0('PC2 ',pc2_importance,'%')),
                      zaxis = list(title = paste0('PC3 ',pc3_importance,'%'))))
q
```

PCA struggles to differentiate between the time stages. PC2 clearly separates by transmission method. While PC1 and PC3 vaguely clusters similar times together.

## PCA but only including the _cir_ sequences {.tabset}

### 2D:

```{r onlycir, fig.cap = 'PCA plot of the cir gene expression of 24h samples'}
pca_function(twentyfour_ct_comb, genevec = cir_id)
# orca(pca_function(twentyfour_ct_comb, 
#                   genevec = cir_id,
#                   scale.pca = TRUE, 
#                   legend_settings = list(font = list(size = 8))),
#      "tl19-07_audreybrugat24hchabaudi_2D-PCA-cir.pdf")
```

The rMT samples appear to contain much greater variation than the tightly clustered SBP samples.

### 3D:

```{r pca_onlycir_3d, fig.cap = 'Three dimensional PCA plot of the cir gene expression of 24h samples'}
pca_function(twentyfour_ct_comb, genevec = cir_id, three.dimensional = TRUE)
```

Looks like they both form their own separate clusters of cycling pir expression.

### Biplot:

```{r pca_onlycir_pc2-pc3, fig.cap = 'Biplot of cir gene expression of 24h samples'}
twentyfour_tpm_forpca <- data.frame(filter(twentyfour_tpm, Geneid %in% cir_id))
rownames(twentyfour_tpm_forpca) <- sapply(twentyfour_tpm_forpca$Geneid, 
                                          function(x){ 
                                            paste(x, 
                                                  chabaudi_gene_info$Product.Description[match(x,
                                                                              chabaudi_gene_info$Gene.ID)])
                                          })
twentyfour_tpm_pca_onlycir <- prcomp(select(twentyfour_tpm_forpca, -Geneid),
                                      center = TRUE, 
                                      scale. = TRUE)

plot_ly_biplot(pca_object = twentyfour_tpm_pca_onlycir,
               scale.loads = 300,
               gene_info = chabaudi_gene_info)

```

Heatmap of the five _pirs_ with the greatest impact on the cir-only PCA (greatest modulus):

```{r pca_onlycir_heatmap, fig.cap = 'Expression heatmap of the five cir genes with the highest magnitude variable loading values in the PCA'}
onlycir_loadings <- data.frame(Geneid = rownames(twentyfour_tpm_pca_onlycir$x),
                                twentyfour_tpm_pca_onlycir$x)

#Heatmap of the cir genes with greatest modulus from the origin
top_pca_cir <- data.frame(onlycir_loadings) %>% 
  mutate(length = sqrt((PC1^2)*(PC2^2))) %>% 
  dplyr::arrange(desc(length)) %>% 
  select(c(Geneid, PC1, PC2, PC3, length)) %>% 
  .$Geneid %>% 
  .[1:5] %>% 
  str_extract(pattern = 'PCHAS_[[:digit:]]+')
draw_heatmap_chabaudi_24h(datasets = twentyfour_ct, 
                          genelist = top_pca_cir, 
                          log_it = TRUE)
# ggbiplot(twentyfour_tpm_pca_onlycir)
```

Both the major cirs are good for distinguishing the samples from each other, probably because they are the greatest signals. Some others clearly distinguish between rMT and SBP.

## PCA without the _cir_ sequences

```{r pca_no_cir, fig.cap='PCA plot of all gene expression, without the cir genes, of 24h samples'}
geneid_nocir <- twentyfour_ct_comb$counts$Geneid[which(!twentyfour_ct_comb$counts$Geneid %in% cir_id)]
pca_function(twentyfour_ct_comb, 
             genevec = geneid_nocir)
```

Looks much the same as the overall PCA.

## PCAs with the MT v SBP pseudogene removed {.tabset}

 ~~Should do this but with rescaling of the TPM.~~
 
### 2D:

```{r pca_no_pseudogene, fig.cap='PCA plot of all gene expression, without the rMT-high pseudogene, of 24h samples'}
geneid_nopseudo <- twentyfour_ct_comb$counts$Geneid[which(!twentyfour_ct_comb$counts$Geneid %in% 'PCHAS_0420800')] 
pca_function(twentyfour_ct_comb, 
             genevec = geneid_nopseudo, 
             scale.pca = TRUE, 
             legend_settings = list(font = list(size = 8)))
orca(pca_function(twentyfour_ct_comb, 
                  genevec = geneid_nopseudo, 
                  scale.pca = TRUE, 
                  legend_settings = list(font = list(size = 8))),
     "tl19-07_audreybrugat24hchabaudi_2D-PCA-nopseudogene.pdf")
# pca_function(twentyfour_ct_comb, genevec = geneid_nopseudo, scale.pca = FALSE)
```

### 3D:

```{r pca_3d_no_pseudogene, fig.cap = 'Three dimensional PCA plot of all gene expression, without the rMT-high pseudogene, of 24h samples'}
pca_function(twentyfour_ct_comb, 
             genevec = geneid_nopseudo, 
             scale.pca = TRUE, 
             three.dimensional = TRUE)
```

Removing cirs leads to no change in the PCA but removing the pseudogene PCHAS_0420800 has a massive impact!

Get a sort of ring shape (although there's quite a 'jump' between late trophs and earlier ring stages) showing transcriptional progression, although this is best described by PC2 and PC3 which only account for 15% of variation.

PC1 focusses on variation due to the schizont and SBP early-mid ring samples. 

### Biplot:

```{r pca_no_pseudogene_loadings_plot}
twentyfour_tpm_forpca <- data.frame(
  filter(
    twentyfour_ct_comb$tpm, 
    Geneid %in% geneid_nopseudo)
)
rownames(twentyfour_tpm_forpca) <- sapply(twentyfour_tpm_forpca$Geneid, 
                                          function(x){ 
                                            paste(x, 
                                                  chabaudi_gene_info$Product.Description[match(x,
                                                                              chabaudi_gene_info$Gene.ID)])
                                          })
twentyfour_tpm_pca_nopseudo <- prcomp(select(twentyfour_tpm_forpca, -Geneid),
                                      center = TRUE, 
                                      scale. = TRUE)
plot_ly_biplot(twentyfour_tpm_pca_nopseudo,
               textposition = 'left')

```

## PCA without the schizont samples (and also without the pseudogene)

```{r}
twentyfour_ct_comb_noschiz <- list(
  tpm = select_at(
    twentyfour_ct_comb$tpm,
    vars(
      -matches('sch')
    )
  ),
  experiment = '24h-noschizont'
)
pca_function(twentyfour_ct_comb_noschiz, 
             genevec = geneid_nopseudo, 
             scale.pca = TRUE, 
             colornames = colornames,
             three.dimensional = TRUE)
```


## PCA without the schizont and Early.Mid.Rings samples which dominate PC1 (and also without the pseudogene)

```{r pca_no_pseudogene_no_schizont, messages = FALSE}
twentyfour_ct_comb_noschiz_noring <- list(
  tpm = select_at(
    twentyfour_ct_comb$tpm,
    vars(
      -matches('sch|Early.Mid.Rings')
    )
  ),
  experiment = '24h-noschizont-noSBPearlymidring'
)
pca_function(twentyfour_ct_comb_noschiz_noring, 
             genevec = geneid_nopseudo, 
             scale.pca = TRUE, 
             colornames = colornames,
             three.dimensional = TRUE)
# pca_function(twentyfour_ct_comb, genevec = geneid_nopseudo, scale.pca = FALSE)
orca(pca_function(twentyfour_ct_comb_noschiz, 
                  genevec = geneid_nopseudo, 
                  scale.pca = TRUE, 
                  colornames = colornames,
                  legend_settings = list(font = list(size = 8))),
     "tl19-07_audreybrugat24hchabaudi_2D-PCA-nopseudogene-noschizorearlymidrings.pdf")
```

Removing just the schizonts (not shown) doesn't make PC1 distinguish the samples much better, and the Early.Mid.Rings still are the most separated by the component. Remove both and a ring is produced just with PC1 and PC2.

## PC5 and PC6 of original PCA

Could also look at different principal component where the pseudogene is having less impact to remove the effect of the pseudogene.

```{r pseudogene_pca_component}
twentyfour_tpm_pca$x[rownames(twentyfour_tpm_pca$x) %in% 'PCHAS_0420800',,drop=FALSE][,1:9, drop=FALSE]
#PC5 and PC6 show much less impact from the pseudogene

twentyfour_tpm_pca_coords <- data.frame(sample = rownames(twentyfour_tpm_pca_var$coord),
                                        twentyfour_tpm_pca_var$coord) %>% 
  dplyr::mutate(stage = gsub(sample, pattern = '_[[:digit:]]$', replacement = '')) %>% 
  dplyr::mutate(time = str_split_fixed(stage, pattern = '_', n = 2)[,2]) %>% 
  dplyr::mutate(transmission = str_split_fixed(sample, pattern = '_', n = 3)[,1])

pc5_importance <- round(pca_importance$PC5[2]*100, digits = 1)
pc6_importance <- round(pca_importance$PC6[2]*100, digits = 1)

pl <- plot_ly(twentyfour_tpm_pca_coords, 
             x  = ~Dim.5, y = ~Dim.6,
             type = 'scatter', mode = 'markers',
             color = ~time, text = ~sample,
             colors = colornames,
             # size = ~total_features,
             marker = list(opacity = 1, size = 16),
             symbol = ~transmission, symbols = c('circle','x')) %>% 
  layout(xaxis = list(title = paste0('PC5 ',pc5_importance,'%')),
         yaxis = list(title = paste0('PC6 ',pc6_importance,'%')))
pl
```

I don't think this is particularly insightful because the variance explained by PC5 and PC6 is only 2.3% and the PCA doesn't really show much anyway. 

Notes:

* Shouldn't make a big difference if we set scale. = FALSE, could try with scale. = TRUE on the counts?

* If you don't scale need to make sure that what's affecting the PCA is something that you're interested in.

* Sparse principal components could be used? Allows you to set a threshold for PCA.

* PC1 separates by mean effect, so basically the highest expressed genes. PC2 onwards separates by harder to understand, subtler differences.

# Removing the pseudogene and re-scaling the TPM data

```{r rescale_tpm}

twentyfour_tpm_nopseudo <- twentyfour_ct_comb$tpm %>% 
  filter(!Geneid %in% 'PCHAS_0420800')

twentyfour_tpm_rescale_nopseudo <- lapply(colnames(twentyfour_tpm_nopseudo), 
                                          function(column_name){
                                            column <- getElement(twentyfour_tpm_nopseudo, 
                                                                 paste(column_name))
                                            if(is.numeric(column)){
                                              #is.numeric to avoid trying to scale the Geneid column
                                              tpm_scale_factor <- 1e6 / sum(column)
                                              tpm_scaled <- as.numeric(column*tpm_scale_factor)
                                            }else{
                                              tpm_scaled <- column
                                            }
                                            return(tpm_scaled)
                                          }) %>% 
  bind_cols

colnames(twentyfour_tpm_rescale_nopseudo) <- colnames(twentyfour_tpm_nopseudo)
twentyfour_tpm_rescale_nopseudo_t <- list(tpm = twentyfour_tpm_rescale_nopseudo)
# apply(twentyfour_tpm_rescale_nopseudo[,-1], 2, sum)

#Setting the re-scaled version as the default from now on
#Setting twentyfour_tpm_ct core dataset - removed pseudogene and re-scaled
twentyfour_ct_comb <- twentyfour_tpm_rescale_nopseudo_t


write_xlsx(select(twentyfour_ct_comb$tpm, 
                  -matches('sch')),
           'tl19-07_TPM_both_nopseudoRescaled_labelsStage_allSamples.xlsx')

twentyfour_ct_rescale <- lapply(twentyfour_ct, 
                                function(list_element){
                                  tpm_data <- list_element %>% 
                                    .$tpm %>% 
                                    filter(!Geneid %in% 'PCHAS_0420800')
                                    
                                  rescaled_tpm <- lapply(colnames(tpm_data), 
                                                         function(column_name){
                                                           column <- getElement(tpm_data, 
                                                                                paste(column_name))
                                                           if(is.numeric(column)){
                                                             #is.numeric to avoid trying to scale the Geneid column
                                                             tpm_scale_factor <- 1e6 / sum(column)
                                                             tpm_scaled <- as.numeric(column*tpm_scale_factor)
                                                           }else{
                                                             tpm_scaled <- column
                                                           }
                                                           return(tpm_scaled)
                                                         }) %>% 
                                    bind_cols
                                  colnames(rescaled_tpm) <-  colnames(list_element$tpm)
                                  list_element$tpm <- rescaled_tpm
                                  return(
                                    list_element
                                  )
                                })
names(twentyfour_ct_rescale) <- unlist(lapply(twentyfour_ct_rescale, getElement, 'experiment'))
lapply(twentyfour_ct_rescale, function(list_element){
  apply(list_element$tpm[,-1], 2, sum) # == 1e6
})
lapply(twentyfour_ct_rescale, function(list_element){
  nrow(list_element$tpm) # == 5363
})

write_xlsx(twentyfour_ct_rescale$rMT$tpm,
           'tl19-07_TPM_rMT_nopseudoRescaled_labelsStage_allSamples.xlsx')
write_xlsx(twentyfour_ct_rescale$SBP$tpm,
           'tl19-07_TPM_SBP_nopseudoRescaled_labelsStage_allSamples.xlsx')

#Setting twentyfour_ct core dataset - removed pseudogene and re-scaled.
twentyfour_ct <- twentyfour_ct_rescale

```

Removing the pseuodgene then re-scaling so that all samples add up to a million TPM again.

```{r shortform_tpm_df}
## Setting core dataset twentyfour_avgtpm and twentyfour_avgtpm_noschz - both rescaled w/o the pseudogene.

#Generate short-form version of twentyfour_top  using the mean_tpm:
twentyfour_avgtpm <- lapply(twentyfour_top, 
       function(experiment_element){
         tpm_df <- dcast(experiment_element$tpm, 
                         Geneid ~ stage, 
                         value.var = 'mean_tpm') %>% 
           filter(!Geneid %in% 'PCHAS_0420800')
         
         #Remove pseudogene and rescale
         rescaled_tpm <- lapply(colnames(tpm_df), 
                                function(column_name){
                                  column <- getElement(tpm_df, 
                                                       paste(column_name))
                                  if(is.numeric(column)){
                                    #is.numeric to avoid trying to scale the Geneid column
                                    tpm_scale_factor <- 1e6 / sum(column)
                                    tpm_scaled <- as.numeric(column*tpm_scale_factor)
                                  }else{
                                    tpm_scaled <- column
                                  }
                                  return(tpm_scaled)
                                }) %>% 
           bind_cols
         colnames(rescaled_tpm) <-  colnames(tpm_df)
         
         return(
           list(tpm = rescaled_tpm,
                experiment = experiment_element$experiment)
         )
       })

names(twentyfour_avgtpm) <- sapply(twentyfour_avgtpm, getElement, 'experiment')

write_xlsx(twentyfour_avgtpm$rMT$tpm,
           'tl19-07_TPM_rMT_nopseudoRescaled_labelsStage_meanTPM.xlsx')
write_xlsx(twentyfour_avgtpm$SBP$tpm,
           'tl19-07_TPM_SBP_nopseudoRescaled_labelsStage_meanTPM.xlsx')

twentyfour_avgtpm_labelTimepoints <- twentyfour_avgtpm

colnames(twentyfour_avgtpm_labelTimepoints$rMT$tpm) <- ifelse(
  !colnames(twentyfour_avgtpm_labelTimepoints$rMT$tpm) %in% c('Geneid', 'sch.culture'),
  times_stages_table$time[
    match(colnames(twentyfour_avgtpm_labelTimepoints$rMT$tpm),
          times_stages_table$r_stage_diff_count)
  ],
  colnames(twentyfour_avgtpm_labelTimepoints$rMT$tpm)
)
write_xlsx(twentyfour_avgtpm_labelTimepoints$rMT$tpm,
           'tl19-07_TPM_rMT_nopseudoRescaled_labelsTime_meanTPM.xlsx')

colnames(twentyfour_avgtpm_labelTimepoints$SBP$tpm) <- ifelse(
  !colnames(twentyfour_avgtpm_labelTimepoints$SBP$tpm) %in% c('Geneid', 'sch.culture'),
  times_stages_table$time[
    match(colnames(twentyfour_avgtpm_labelTimepoints$SBP$tpm),
          times_stages_table$r_stage_diff_count)
  ],
  colnames(twentyfour_avgtpm_labelTimepoints$SBP$tpm)
)
write_xlsx(twentyfour_avgtpm_labelTimepoints$SBP$tpm,
           'tl19-07_TPM_SBP_nopseudoRescaled_labelsTime_meanTPM.xlsx')

# lapply(twentyfour_avgtpm,
#        function(tmp){
#          apply(
#            tmp$tpm[-1],
#            2,
#            sum
#          )
#        })

#Above is a check that they all add up to 1e6

# Setting twentyfour_avgtpm_noschz core dataset

twentyfour_avgtpm_noschz <- lapply(twentyfour_avgtpm, 
                                   function(experiment_data){
                                     tpm_df <- experiment_data$tpm
                                     tpm_df <- tpm_df[!str_detect(colnames(tpm_df), pattern = 'sch')]
                                     # Remove the column with 'sch' pattern in it = schizonts
                                     list(tpm = tpm_df,
                                          experiment = experiment_data$experiment)
                                   })

# lapply(twentyfour_avgtpm_noschz,
#        function(tmp){
#          apply(
#            tmp$tpm[-1],
#            2,
#            sum
#          )
#        })

#Above is a check that they all add up to 1e6

```

# 3D PCA to save

```{r 3d_PCA_save_rgl}
library('rgl')
library('magick')

twentyfour_ct_rescale_allTPM <- lapply(names(twentyfour_ct_rescale), 
                                       function(list_name){
                                         getElement(twentyfour_ct_rescale, 
                                                    paste(list_name))$tpm %>% 
                                           select(!matches('sch')) %>% 
                                           rename_with(~ paste0(list_name,
                                                                '_',
                                                                .x),
                                                       matches('[[:digit:]]{2}h'))
                                       }) %>% 
  Reduce(merge, .) %>% 
  column_to_rownames(var = 'Geneid')
# apply(twentyfour_ct_rescale_allTPM, 2, function(x) 1e10*(sum(x) - 1e6))

twentyfour_ct_rescale_allTPM_pca <- prcomp(twentyfour_ct_rescale_allTPM,
       center = TRUE, 
       scale. = TRUE)

twentyfour_ct_rescale_allTPM_pca_var <- get_pca_var(twentyfour_ct_rescale_allTPM_pca)
twentyfour_ct_rescale_allTPM_pca_coords <- data.frame(twentyfour_ct_rescale_allTPM_pca_var$coord)

twentyfour_ct_rescale_allTPM_pca_coords <- data.frame(
  sample = rownames(twentyfour_ct_rescale_allTPM_pca_var$coord),
  PC1 = twentyfour_ct_rescale_allTPM_pca_coords$Dim.1, 
  PC3 = twentyfour_ct_rescale_allTPM_pca_coords$Dim.3, 
  PC2 = twentyfour_ct_rescale_allTPM_pca_coords$Dim.2
) %>% 
  dplyr::mutate(stage = gsub(sample,
                             pattern = "_[[:digit:]]$", 
                             replacement = "")) %>% 
  dplyr::mutate(time = str_split_fixed(stage, 
                                       pattern = "_", 
                                       n = 2)[, 2]) %>% 
  dplyr::mutate(transmission = str_split_fixed(sample, 
                                               pattern = "_", 
                                               n = 3)[, 1])

colornames <- viridis(length(unique(twentyfour_ct_rescale_allTPM_pca_coords$time)))
colornames <- setNames(colornames, sort(unique(twentyfour_ct_rescale_allTPM_pca_coords$time)))

twentyfour_ct_rescale_allTPM_pca_coords$cols <- colornames[
  match(twentyfour_ct_rescale_allTPM_pca_coords$time,
        names(colornames))
]

pl <- plot_ly(twentyfour_tpm_pca_coords, x = ~PC1, y = ~PC2, 
              z = ~PC3, mode = "markers", type = "scatter3d", color = ~time, 
              text = ~sample, colors = colornames, marker = list(opacity = 1, 
                                                                 size = 5), symbol = ~transmission, symbols = c("circle", 
                                                                                                                "x")) %>% layout(scene = list(xaxis = list(title = paste0("PC1 ", 
                                                                                                                                                                          pc1_importance, "%")), yaxis = list(title = paste0("PC2 ", 
                                                                                                                                                                                                                             pc2_importance, "%")), zaxis = list(title = paste0("PC3 ", 
                                                                                                                                                                                                                                                                                pc3_importance, "%"))))

plot3d(
  twentyfour_ct_rescale_allTPM_pca_coords$PC1,
  twentyfour_ct_rescale_allTPM_pca_coords$PC2,
  twentyfour_ct_rescale_allTPM_pca_coords$PC3,
  col = twentyfour_ct_rescale_allTPM_pca_coords$cols,
  type = "s", 
  radius = .025
)

# colors <- c("royalblue1", "darkcyan", "oldlace")
# iris$color <- colors[ as.numeric( as.factor(iris$Species) ) ]
# # Static chart
# plot3d( iris[,1], iris[,2], iris[,3], col = iris$color, type = "s", radius = .2 )
# 
# # We can indicate the axis and the rotation velocity
# play3d( spin3d( axis = c(0, 0, 1), rpm = 20), duration = 10 )
```


# Amount of _cir_ expression per stage/sample

```{r amount of cir expression}

twentyfour_ct_comb_cir <- twentyfour_ct_comb$tpm %>% 
  filter(Geneid %in% cir_id) %>% 
  melt(id.vars = 'Geneid', variable.name = 'sample', value.name = 'tpm') %>% 
  mutate(stage = gsub(sample, pattern = '_[[:digit:]]$', replacement = '')) %>%
  mutate(transmission = str_split_fixed(sample, pattern = '_', n = 3)[,1]) %>%
  mutate(diff_count = str_split_fixed(sample, pattern = '_', n = 4)[,3]) %>% 
  mutate(time = str_split_fixed(sample, pattern = '_', n = 3)[,2]) %>% 
  filter(!(time %in% c('sch', 'Unknown'))) %>% 
  group_by(sample, stage, transmission, time, diff_count) %>% 
  dplyr::summarise(sum_tpm = sum(tpm))

cir_plot <- twentyfour_ct_comb_cir

  #Want it to be in the right order, but the line function won't work with a discrete scale
  order_diff_counts <- c("Early.Rings",
                         "Early.Mid.Rings",
                         "Late.Mid.Rings",
                         "Late.Rings",
                         "Rings.Troph.conversion",
                         "Early.Trophs",
                         "Mid.Trophs",
                         "Late.Trophs")
  order_for_plot <- data.frame(order_diff_counts,
                               order = seq(1, length(order_diff_counts), 1))
  cir_plot <- mutate(cir_plot, 
                     order_plot = order_for_plot$order[match(diff_count, 
                                                             order_for_plot$order_diff_counts)])

# cir_plot <- filter(twentyfour_ct_comb_cir, !(time %in% c('schz', 'Unknown'))) %>% 
#   mutate(time = as.numeric(time))

p <- ggplot(data = cir_plot, 
            aes(x = order_plot, 
                y = sum_tpm,
                fill = transmission)) +
  stat_summary(fun.y = median, fun.ymin = median, fun.ymax = median,
               geom = "bar", width = 0.75, size = 0.25, position = 'dodge') +
  geom_point(stat = 'identity', position = position_dodge(width = 0.75)) +
  geom_smooth(method = 'loess', se = FALSE, color = 'black', aes(linetype = transmission)) +
  scale_fill_manual(values = cbPalette) +
  scale_linetype_manual(values = c('dotted', 'dashed')) +
    scale_x_continuous(breaks = order_for_plot$order, 
                       labels = order_for_plot$order_diff_counts) +
  ylab(expression('Total'~italic(pir)~'TPM')) +
  theme_classic() +
  theme(axis.text.x=element_text(angle = 90, vjust = 0.5))
p
ggsave(p, filename = 'tl19-07_24hchabaudi_pirexpression_barchartLOESS.pdf')

total_tpm_expression_stacked(list(cir = cir_id),
                             stack_genes = c('PCHAS_0101200'),
                             stack_label = 'Ancestral pir?',
                             stack_grouping = FALSE)
total_tpm_expression_stacked(list_genes = list(cir = cir_id),
                             stack_genes = c('PCHAS_0101200', 
                                             # 'PCHAS_0524800',
                                             'PCHAS_1100300'),
                             stack_label = 'pir labels',
                             stack_grouping = FALSE,
                             save = TRUE)
```



##  Stacked bar chart

```{r function_total_tpm_expression_stacked_all}
total_tpm_expression_stacked_all <- function(
    list_genes, 
  save = FALSE,
  tpm_data = twentyfour_ct,
  stage_str_extract_regex_pattern = '(?<=[[:digit:]]h_).+(?=_[[:digit:]]+)|sch.culture',
  stack_genes = cir_id,
  stack_names = c('Yes',
                  'No'),
  stack_label = 'Cir genes',
  stack_grouping = TRUE
){
  lapply(names(list_genes), 
         function(list_name){
           #list_name <- names(list_genes)[1]
           paste(list_name)
           gene_id <- getElement(list_genes, paste(list_name))
           list_tpms_line <- lapply(tpm_data, 
                                    function(input){
                                      tpm_data <- input$tpm %>% 
                                        filter(Geneid %in% gene_id) %>% 
                                        melt(id.vars = 'Geneid', variable.name = 'sample', value.name = 'tpm') %>% 
                                        mutate(stage = str_extract(sample, 
                                                                   pattern = paste(stage_str_extract_regex_pattern)),
                                               stack_group = Geneid
                                               ) %>% 
                                        group_by(stage, sample, stack_group) %>% 
                                        dplyr::summarise(total_tpm = sum(tpm))
                                      
                                      #Make stages with no cirs in the sample give a zero 
                                      if(!all(colnames(input$tpm) %in% tpm_data$sample)){
                                        missing_stages = colnames(input$tpm)[-1][!colnames(input$tpm)[-1] %in% tpm_data$sample]
                                        missing_stages_data_zero = data.frame(
                                          lapply(missing_stages, 
                                                 function(missing_st){
                                                   data.frame(stage = unlist(
                                                     str_extract(
                                                       missing_st, 
                                                       pattern = paste(stage_str_extract_regex_pattern))),
                                                     sample = missing_st,
                                                     total_tpm = 0)
                                                 })
                                        )
                                        tpm_data = bind_rows(tpm_data, missing_stages_data_zero)
                                      }
                                      
             #Add experiment column
             tpm_data$experiment = rep(input$experiment, times = nrow(tpm_data))
             max_tpm = if(max(tpm_data$total_tpm) < 10){
               c(seq(0,mround(max(tpm_data$total_tpm),1),1))
             }else{
               c(seq(0,mround(max(tpm_data$total_tpm),5),5))
             }
             
             #Get the average data for the line graph
             tpm_data_line = tpm_data %>% 
               ungroup %>% 
               group_by(stage, experiment, stack_group) %>% 
               dplyr::summarise(total_tpm_median = median(total_tpm),
                                Number_of_replicates = n()) %>% 
               arrange(stage)
             
             return(tpm_data_line)
           })
           
           tpm_data_line <- bind_rows(list_tpms_line)
           #Apply ordering if it is specified
           if(!is.null(order_vector)){
             tpm_data_line$stage = factor(tpm_data_line$stage, 
                                          levels = ordering(tpm_data_line$stage,
                                                            order_vector))
           }
           
           tpm_data_line
           
           #Calculate the range for the y value to make it look nicer
           stacked_max <- tpm_data_line %>% 
                                ungroup %>% 
                                group_by(stage, experiment) %>% 
                                dplyr::summarise(max_tpm = sum(total_tpm_median)) %>% 
                                .$max_tpm %>% 
             max
           
           max_tpm <- c(
             seq(
               0,
               mround(
                 stacked_max,
                 500),
               length.out = 11)
           )
           
           y <- ggplot(data = tpm_data_line, 
                       aes(
                         x = experiment,
                         y = total_tpm_median, 
                         fill = stack_group
                       )
           ) +
             geom_bar(position = position_stack(),
                      stat = 'identity',
                      colour = 'black',
                      size = 0.1) +
             scale_fill_manual(
               breaks = c(stack_genes, 'Other'),
               values = c( #Remove the stack_genes from the 'grey' cir group
                 setNames(cbPalette[1:length(c(stack_genes))],
                          c(stack_genes)),
                 setNames(rep_len('white', 
                                  length.out = length(
                                    str_subset(unique(tpm_data_line$stack_group),
                                               pattern = stack_genes, 
                                               negate = TRUE)
                                  )),
                          str_subset(unique(tpm_data_line$stack_group),
                                     pattern = stack_genes, 
                                     negate = TRUE)
                 )
               )
               #Need to have limits and values otherwise when there are only cir genes (i.e. only 'Yes') the colour 
               # palette will mess up and only use one, wrong colour. Limits tells it there are always two values.
             ) +
             scale_color_manual('black') %>% 
             labs(fill = stack_label) +
             scale_y_continuous(breaks = max_tpm) +
             theme_classic() +
             scale_size(range = c(0,3)) +
             ylab(
               bquote('total '~italic(.(list_name))~' TPM')
             ) + 
             facet_grid(.~stage, 
                        scales = "free_x",
                        space = "free_x") +
             theme(
               axis.title.x=element_blank(),
               axis.text.x=element_text(angle = 90, 
                                        size = 5, 
                                        vjust = 0.5),
               axis.text.y = element_text(size = 5),
               axis.title.y = element_text(size = 8),
               legend.title = element_text(size = 7),
               legend.text = element_text(size = 5),
               legend.key.size = unit(3,'mm'),
               legend.key.width = unit(2,'mm'),
               strip.text.x = element_text(size=4, 
                                           face = 'bold', 
                                           angle = 90),
               strip.background = element_rect(
                 color="black", 
                 size=0.1, 
                 linetype="solid"
               )
             )
           
           #This bit is to change the colour of the facet boxes
           
           g <- ggplot_gtable(ggplot_build(y))
           strip_t <- which(grepl('strip-t', g$layout$name))
           stage_vec <- unique(
             levels(tpm_data_line$stage)
           )
           fills <- case_when(str_detect(stage_vec, pattern = 'Asexual') ~ 'coral1' ,
                              str_detect(stage_vec, pattern = 'Liver') ~ 'plum2',
                              str_detect(stage_vec, pattern = 'Gametocyte') ~ 'lightskyblue1',
                              str_detect(stage_vec, pattern  = 'Blood-Meal|Sporozoite|Ookinete') ~ 'lightgreen')
           k <- 1
           for (i in strip_t) {
             j <- which(grepl('rect', g$grobs[[i]]$grobs[[1]]$childrenOrder))
             g$grobs[[i]]$grobs[[1]]$children[[j]]$gp$fill <- fills[k]
             k <- k+1
           }

           if(save == TRUE){
             ggsave2(paste0('tl19-07_',
                            gsub(list_name, 
                                 pattern  = ' ', 
                                 replacement = '_'),
                            '_totalTPM_barchart.pdf'),
                     plot = g,
                     dpi = 300,
                     width = 15,
                     height = 10,
                     units = 'cm')
           }
           
           grid.newpage()
           grid.draw(g)
           
         })
}


total_tpm_expression_stacked_all(list_genes = list(cir = cir_id),
                             stack_genes = c('PCHAS_0101200', 
                                             # 'PCHAS_0524800',
                                             'PCHAS_1100300'),
                             stack_label = 'pir genes',
                             stack_names = c('-', 
                                             'Other'),
                             stack_grouping = FALSE,
                             save = TRUE)
```

Curves represent a local regression (LOESS) function.

The pattern of cir expression is the same between SBP and MT (more-or-less) and at the 17.00 and 20.00 time points it is possible that the amount of cir expression is actually greater in SBP v MT. Both transmission methods show an peak of expression around 11-14h, correlating with the onset of sequestration?

For completeness the schizont sample is included below:

```{r}
cir_plot_schz <- twentyfour_ct_comb$tpm %>% 
  filter(Geneid %in% cir_id) %>% 
  melt(id.vars = 'Geneid', variable.name = 'sample', value.name = 'tpm') %>% 
  mutate(stage = gsub(sample, pattern = '_[[:digit:]]$', replacement = '')) %>%
  mutate(transmission = str_extract(stage, pattern = '^(rMT|SBP)')) %>%
  mutate(time = str_extract(stage, pattern = '(?<=[[:alpha:]]_)([[:alpha:]]+\\.[[:alpha:]]+)+$')) %>% 
  filter(grepl(time, pattern =  c('sch'))) %>% 
  group_by(sample, stage, transmission, time) %>% 
  dplyr::summarise(sum_tpm = sum(tpm))
p <- ggplot(data = cir_plot_schz, 
            aes(x = time, 
                y = sum_tpm,
                fill = transmission)) +
  stat_summary(fun.y = median, fun.ymin = median, fun.ymax = median,
               geom = "bar", width = 0.75, size = 0.25, position = 'dodge') +
  geom_point(stat = 'identity', position = position_dodge(width = 0.75)) +
  scale_fill_manual(values = cbPalette) +
  ylab(expression('Total'~italic(cir)~'TPM')) +
  scale_y_continuous(limits = c(0, 10000)) +
  theme(axis.text.x=element_text(angle = 90, vjust = 0.5)) +
  theme_classic()
p
```

# Heatmap of top _pir_ expression and orthology across _Plasmodium_

Need to verify that the strains removed don't have any 'extra' orthologs compared to the strain that I keep.

```{r download_ortholog_data}
chab_pir_ortho <- read_csv('PlasmoDBv48_PchabaudiPIRs_transformedbyorthology.csv') %>% 
  mutate(Geneid = `Gene ID`,
         Input_Geneid = `Input Ortholog(s)`) %>% 
  filter(!(Organism %in% 'Plasmodium chabaudi chabaudi')) %>% 
  tidyr::separate_rows(Input_Geneid, 
                       sep = ',') %>% 
  mutate(Organism = str_replace(Organism,
                                pattern = 'lasmodium',
                                replacement = '\\.'))

#Remove paralogs and split rows out by the Input sequences 

chab_pir_ortho_synt <- read_csv('PlasmoDBv48_PchabaudiPIRs_transformedbyorthology_syntenic.csv')

chab_pir_ortho <- filter(
  chab_pir_ortho,
  !Organism %in% c(
    'P. vivax Sal-1',
    'P. yoelii yoelii 17X',
    'P. yoelii yoelii 17XML',
    'P. vinckei vinckei strain vinckei'
  )
) %>% 
  mutate(
    syntenic = ifelse(`Geneid` %in% chab_pir_ortho_synt$`Gene ID`,
                           'Yes',
                           'No'),
         Organism = str_extract(Organism,
                                pattern = 'P. [[:alpha:]]+')
  )

# unique(chab_pir_ortho$Organism)

chab_pir_ortho %>%
  mutate(species = str_extract(Geneid, pattern = '^.+(?>_)')) %>%
  group_by(Input_Geneid) %>%
  dplyr::summarise(orthologs = paste(unique(`Organism`), collapse = ','))  %>%
  tidyr::separate_rows(orthologs, sep = ',') %>%
  group_by(Input_Geneid) %>%
  dplyr::summarise(num = n()) %>%
  arrange(desc(num)) %>%
  mutate(product = chabaudi_gene_info$handy_descriptions[match(Input_Geneid,
                                                         chabaudi_gene_info$Geneid)])

chab_pir_ortho %>%
  mutate(species = str_extract(Geneid, 
                               pattern = '^.+(?>_)')) %>%
  group_by(Input_Geneid) %>%
  dplyr::summarise(orthologs = paste(unique(`Organism`), 
                                     collapse = ', '))  

```

```{r ortholog_heatmap}

#   #pir_family_name <- names(pir_genes_list_ortho)[1]
#   pir_family <-  getElement(pir_genes_list_ortho, 
#                             paste(pir_family_name))
#   #Need to convert this into a character vector for the filter function
#   pir_family <- apply(pir_family, 1, as.character)

threshold <- 0

#Want Number for whether the orthologue is present in each species
pir_ortholog_species <- chab_pir_ortho %>% 
  filter(Input_Geneid %in% cir_id) %>% 
  purrr::modify_if(is.character, 
            as.factor) %>% 
  group_by(Organism, 
           Input_Geneid, 
           .drop = FALSE) %>%
  #.drop must be FALSE otherwise dplyr will drop zero values
  select(Input_Geneid, 
         Organism, syntenic) %>%
  dcast(Input_Geneid ~ Organism, 
        value.var = 'syntenic', 
        fun.aggregate = function(syntenic){
          if(any(syntenic == 'Yes')){
            2
          }else if(length(syntenic) > 0){
            1
          }else{
            0
          }
        })

#Add in the genes which have no orthologs
pir_ortholog_species <- pir_ortholog_species %>% 
  tidyr::complete(Input_Geneid = cir_id)
  
  #Alter here whether you want only the genes with orthologs, or all genes even if they don't have an ortholog
  
  pir_ortholog_species <-  dplyr::rename(pir_ortholog_species, 
                                  rowname = Input_Geneid) %>%
    mutate(rowname = str_replace(as.character(rowname), 
                                 pattern = 'PCHAS_', 
                                 replacement = '')) %>%
    arrange(
      match(
        rowname,
        str_sort(
          rowname,
          numeric = TRUE
        )
      )
    ) %>%
    #Use str_sort because the character format is sorted differently to how I want it normally
    column_to_rownames()
  pir_ortholog_species_rownam <- rownames(pir_ortholog_species)
  pir_ortholog_species <- apply(pir_ortholog_species, 2, function(x){
    case_when(
      x == 0 ~ NA_character_,
      x == 1 ~ 'No',
      x == 2 ~ "Yes")
  })
  rownames(pir_ortholog_species) <- pir_ortholog_species_rownam
  
  #Not going to worry about whether they are pseudogenes or not for now
  
  ortho_gene_vec <- rownames(pir_ortholog_species)
  
  heatmap_row_name_fonts <- 10
  heatmap_col_name_fonts <- 10
  heatmap_col_title_fonts <- 15
  
  #Get the TPM data for the pirs family being looked at
  expt_tpms_top_pirs <- lapply(twentyfour_avgtpm_noschz, 
                               function(tpm_input){
                                 # print(paste0('Now doing ', tpm_input$experiment))
                                 tpms <- tpm_input$tpm %>% 
                                   filter(Geneid %in% cir_id)
                                 #Remove PCHAS_ from the gene names for simplicity
                                 rownames(tpms) = str_replace(as.character(tpms$Geneid), 
                                                              pattern = 'PCHAS_', 
                                                              replacement = '')
                                 tpms <- tpms[str_sort(rownames(tpms), 
                                                       numeric = TRUE),]
                                 tpms <- select(tpms, -Geneid)
                                 
    colnames(tpms) <- times_stages_table$time[match(colnames(tpms),
                                                    times_stages_table$r_stage_diff_count)]
    
    tpms <- tpms[,
                 order(colnames(tpms)),
                 drop = FALSE]
    #Ordering using the ordering function and order_vector defined in the functions section.
    
    tpms <- apply(tpms, 2, function(x){ifelse(x >= threshold, 
                                              x, 
                                              NA)}) #Get NA for values under threshold
    tpms <- log1p(tpms)
    if(tpm_input$experiment %>%  is.null){
      tpm_input$experiment = ''
    }
    list = list(tpms, tpm_input$experiment)
    names(list) = c('tpm','experiment')
    return(list)
  })
  
  #if they are all NA then we don't want it to proceed further
  if(
    all(
      unlist(
        lapply(
          expt_tpms_top_pirs, 
          function(x) sapply(x$tpm, 
                             is.na)  
        )
      )
    )
  ){stop()}
    
    maxcol = max(
      unlist(
        lapply(
          expt_tpms_top_pirs, 
          function(x) max(
            x$tpm,
            na.rm = TRUE
          )
        )
      )
    )
    #Get the max TPM value
    
    if(is.na(maxcol)|maxcol<1){maxcol <- 1}
    
    #Re-order both data.frames by the median highest expressed pirs
    
    tpm_order <- order(
      rowMedians(
        sapply(
          lapply(
            expt_tpms_top_pirs,
            function(x) rowMedians(x$tpm)
          ),
          rbind),
        na.rm = TRUE),
      decreasing = TRUE
    )[1:10]

    
    heatmaps = lapply(expt_tpms_top_pirs, 
                      function(tpms){
                        if(tpms$experiment != last(expt_tpms_top_pirs)$experiment){
                          #If it is the final element don't remove the row names
                          rownames(tpms$tpm) = c()
                        }
                        #Setting the name if one is not provided
                        title_name = tpms$experiment
                        #Drawing each heatmap
                        ht = Heatmap(tpms$tpm[tpm_order,, drop = FALSE], 
                                     name = 'log(TPM + 1)', 
                                     col = colorRamp2(c(threshold, 
                                                        maxcol/4, 
                                        maxcol/2, 
                                        3*maxcol/4, 
                                        maxcol), 
                                      viridis(5)),
                     cluster_rows = FALSE, 
                     cluster_columns = FALSE,
                     column_title = paste(title_name),
                     column_title_gp = gpar(fontsize = heatmap_col_title_fonts),
                     row_names_gp = gpar(fontsize = heatmap_row_name_fonts),
                     column_title_rot = 0,
                     column_names_gp = gpar(fontsize = heatmap_col_name_fonts),
                     na_col = 'white', 
                     border = TRUE,
                     border_gp = gpar(col = "black", 
                                      lwd = 2),
                     heatmap_legend_param = list(
                       title = 'log(TPM + 1)', 
                       at = mround(
                         c(log1p(threshold), 
                           seq(0, 
                               maxcol, 
                               length.out = 4)[-1]
                         ), 
                         base = 0.05)
                     )
        )
    })
    
    ortholog_for_heatmap <- as.matrix(pir_ortholog_species)[tpm_order,
                                                            !apply(
                                                              pir_ortholog_species[tpm_order,,drop = FALSE],
                                                              2,
                                                              function(ortho) all(is.na(ortho))
                                                            ),
                                                            drop = FALSE]
    
    ha = Heatmap(ortholog_for_heatmap,
                 name = 'Syntenic Orthologs',
                 na_col = 'white',
                 col = structure(rev(plasma(2)), 
                                 names = c('Yes', 'No')),
                 cluster_rows = FALSE, 
                 cluster_columns = FALSE,
                 column_names_gp = gpar(col = 'darkslategray', 
                                    fontsize = 7*(50/(ncol(ortholog_for_heatmap)+26)), 
                                    fontface = 'italic'),
                 show_column_dend = FALSE,
                 rect_gp = gpar(col = 'white'), 
                 width = unit(4, "cm"),
                 heatmap_legend_param = list(

                     )
    )
    
    ht_list = Reduce('+', heatmaps) #To add the list elements together
    ht_list <- ha + ht_list
    
    if(global_save_var){
      pdf(
        paste0('tl19-07_pir_',
               'orthologs_heatmap.pdf')
        # , width = 17
        , height = 5
      )
      draw(ht_list,
           row_title_side = 'left',
           column_title = 'Malaria stage',
           column_title_side = 'bottom',
           heatmap_legend_side = 'left',
           ht_gap = unit(0.75, "cm"))
      dev.off()
    }
    
    draw(ht_list,
           row_title_side = 'left',
           column_title = 'Malaria stage',
           column_title_side = 'bottom',
           heatmap_legend_side = 'left',
           ht_gap = unit(0.6, "cm"))

```

```{r heatmap_ortho_most_conserved}

    #Re-order by most conserved genes
    
    tpm_order <- order(
      apply(pir_ortholog_species, 
            1, 
            function(ortho_row) sum(!is.na(ortho_row))),
      decreasing = TRUE
    )[1:10]
    
    heatmaps = lapply(expt_tpms_top_pirs, 
                      function(tpms){
                        if(tpms$experiment != last(expt_tpms_top_pirs)$experiment){
                          #If it is the final element don't remove the row names
                          rownames(tpms$tpm) = c()
                        }
                        #Setting the name if one is not provided
                        title_name = tpms$experiment
                        #Drawing each heatmap
                        ht = Heatmap(tpms$tpm[tpm_order,, drop = FALSE], 
                                     name = 'log(TPM + 1)', 
                                     col = colorRamp2(c(threshold, 
                                                        maxcol/4, 
                                        maxcol/2, 
                                        3*maxcol/4, 
                                        maxcol), 
                                      viridis(5)),
                     cluster_rows = FALSE, 
                     cluster_columns = FALSE,
                     column_title = paste(title_name),
                     column_title_gp = gpar(fontsize = heatmap_col_title_fonts),
                     row_names_gp = gpar(fontsize = heatmap_row_name_fonts),
                     column_title_rot = 90,
                     column_names_gp = gpar(fontsize = heatmap_col_name_fonts),
                     na_col = 'white', border = TRUE,
                     heatmap_legend_param = list(
                       title = 'log(TPM + 1)', 
                       at = mround(
                         c(log1p(threshold), 
                           seq(0, 
                               maxcol, 
                               length.out = 4)[-1]
                         ), 
                         base = 0.05)
                     )
        )
    })
    

    ha = Heatmap(as.matrix(pir_ortholog_species)[tpm_order,, drop = FALSE],
                 name = 'Syntenic Orthologs',
                 na_col = 'white',
                 col = structure(rev(plasma(2)), 
                                 names = c('Yes', 'No')),
                 cluster_rows = FALSE, 
                 cluster_columns = FALSE,
                 column_names_gp = gpar(col = 'darkslategray', 
                                        fontsize = 4*(50/(ncol(pir_ortholog_species)+26)), 
                                        fontface = 'italic'),
                 show_column_dend = FALSE,
                 rect_gp = gpar(col = 'white'), 
                 width = unit(4, "cm"),
                 heatmap_legend_param = list(

                     )
                 )
    
    ht_list = Reduce('+', heatmaps) #To add the list elements together
    ht_list <- ha + ht_list
    # pdf(
    #   paste0('tl19-07_pir_',
    #          'orthologs_heatmap.pdf')
    #   # , width = 17
    #   , height = 5
    # )
    draw(ht_list,
         row_title_side = 'left',
         column_title = 'Malaria stage',
         column_title_side = 'bottom',
         heatmap_legend_side = 'left')
    # dev.off()
    
```

# Figure 2b - Heatmap of top S and L gene expression.

```{r colours_clades_phase}
SorL_col <- setNames(
  c(    '#F0E442',
        '#56B4E9',
        '#E69F00',
        '#999999'),
  sort(
    unique(cir_clade_info$SorL)
  )
)

clade_col <- setNames(
  c('#F0E442',
    '#56B4E9',
    '#009E73',
    '#E69F00',
    '#0072B2',
    '#D55E00',
    '#CC79A7',
    '#999999'),
  sort(
    unique(cir_clade_info$clade)
  )
)

```

```{r figure2b_heatmap_table}

#Get the TPM data for the pirs family being looked at
highest_SorL_24h <- lapply(twentyfour_avgtpm_noschz, 
                          function(tpm_input){
                            
                            tpm_data_SorL_stackgenes_top_table <- tpm_input$tpm %>% 
                              filter(Geneid %in% cir_id) %>% 
                              melt(id.vars = 'Geneid', 
                                   variable.name = 'stage', 
                                   value.name = 'total_tpm') %>% 
                              mutate(total_tpm = as.numeric(total_tpm),
                                     SorL = cir_clade_info$SorL[match(Geneid, cir_clade_info$Geneid)],
                                     stage = times_stages_table$time[match(stage, times_stages_table$r_stage_diff_count)]) %>% 
                              filter(str_detect(SorL, 
                                                pattern = 'ancestral|unk', 
                                                negate = TRUE)) %>% 
                              group_by(stage) %>% 
                              mutate(sum_tpm = sum(total_tpm)) %>% 
                              group_by(stage, 
                                       SorL) %>% 
                              slice_max(order_by = total_tpm,
                                        n = 1) %>% 
                              mutate(total_tpm = round(total_tpm, digits = 2),
                                     prop_tpm = round(total_tpm/sum_tpm, digits = 2)) %>% 
                              select(stage, Geneid, SorL, total_tpm, prop_tpm)
                            
                            write.csv(tpm_data_SorL_stackgenes_top_table,
                                      file = paste0('tl19-07_combined_SorL_topperstage_table_', 
                                                    tpm_input$experiment, 
                                                    '.csv'))
                            
                            write_xlsx(tpm_data_SorL_stackgenes_top_table,
                                       paste0('tl19-07_combined_SorL_topperstage_table_', 
                                              tpm_input$experiment, 
                                              '.xlsx'))
                            
                            SorL_kable_index <- rep.int(2, 
                                                        times = length(unique(tpm_data_SorL_stackgenes_top_table$stage)))
                            names(SorL_kable_index) <- unique(tpm_data_SorL_stackgenes_top_table$stage)
                            
                            return(
                              list(dataframe = tpm_data_SorL_stackgenes_top_table, 
                                   table = 
                                     tpm_data_SorL_stackgenes_top_table %>% 
                                     kable(caption = paste(tpm_input$experiment) )%>% 
                                     kable_styling() %>% 
                                     pack_rows(index = SorL_kable_index) %>% 
                                     scroll_box(width = "100%", height = "500px"),
                                   experiment = tpm_input$experiment
                              )
                            )
                          }
)

lapply(highest_SorL_24h, function(expt) expt$table)

```

```{r figure2b_heatmap}

heatmap_row_name_fonts <- 20
heatmap_col_name_fonts <- 15

highest_SorL_pirs_bystage <- sort(
  unique(
    unlist(
      lapply(
        highest_SorL_24h, function(expt) expt$dataframe$Geneid)
    )))

highest_SorL_pirs_bystage_subfams <- data.frame(
  Geneid = str_replace(as.character(highest_SorL_pirs_bystage), 
                                    pattern = 'PCHAS_', 
                                    replacement = ''),
                       subfamily = cir_clade_info$SorL[match(highest_SorL_pirs_bystage
                                                             , cir_clade_info$Geneid)]
  )


ha = Heatmap(
  as.matrix(highest_SorL_pirs_bystage_subfams$subfamily),
  name = 'Subfamily',
  na_col = 'white',
  col = SorL_col,
  cluster_rows = FALSE, 
  cluster_columns = FALSE,
  column_names_gp = gpar(col = 'darkslategray', 
                         fontsize = 12, 
                         fontface = 'italic'),
  show_column_dend = FALSE,
  rect_gp = gpar(col = 'white'), 
  width = unit(1, "cm"),
  heatmap_legend_param = list(
    labels_gp = gpar(fontsize = 10),
    title_gp = gpar(fontsize = 10)
  ),
  show_heatmap_legend = FALSE
  # Going to hide the legend so I can make it manually later with the grid.points that I use in the heatmap body.
)


#Get the TPM data for the pirs family being looked at
expt_tpms_top_pirs <- lapply(twentyfour_avgtpm_noschz, 
                             function(tpm_input){
                               # print(paste0('Now doing ', tpm_input$experiment))
                               tpms <- tpm_input$tpm %>% 
                                 filter(Geneid %in% highest_SorL_pirs_bystage) %>% 
                                 as.data.frame
                               
                               
                               colnames(tpms) <- ifelse(
                                 !colnames(tpms) %in% 'Geneid',
                                                        times_stages_table$time[match(colnames(tpms),
                                                                                      times_stages_table$r_stage_diff_count)],
                                                        'Geneid'
                               )
                               
                               tpms <- tpms[,
                                            order(colnames(tpms)),
                                            drop = FALSE]
                               #Ordering using the ordering function and order_vector defined in the functions section.
                               
                               #Data for the grid.dots for heatmap to show max for each stage
                               max_SorL <- mutate(tpms, 
                                                  SorL = cir_clade_info$SorL[match(Geneid, 
                                                                                   cir_clade_info$Geneid)]) %>% 
                                 group_by(SorL) %>% 
                                 mutate(across(-matches('Geneid|SorL'), 
                                               ~ ifelse(.x == max(.x), 
                                                        SorL, 
                                                        NA))) %>% 
                                 ungroup() %>% 
                                 select(-Geneid, -SorL)
                               
                               #Remove PCHAS_ from the gene names for simplicity
                               rownames(tpms) <- str_replace(as.character(tpms$Geneid), 
                                                             pattern = 'PCHAS_', 
                                                             replacement = '')
                               tpms <- tpms[str_sort(rownames(tpms), 
                                                     numeric = TRUE),]
                               tpms <- select(tpms, -Geneid)
                               
                               tpms <- apply(tpms, 2, function(x){ifelse(x >= threshold, 
                                                                         x, 
                                                                         NA)}) #Get NA for values under threshold
                               tpms <- log1p(tpms)
                               if(tpm_input$experiment %>%  is.null){
                                 tpm_input$experiment = ''
                               }
                               list = list(tpm = tpms, 
                                           experiment = tpm_input$experiment,
                                           max_SorL = max_SorL)
                               return(list)
                             })

    maxcol <- max(
      unlist(
        lapply(
          expt_tpms_top_pirs, 
          function(x) max(
            x$tpm,
            na.rm = TRUE
          )
        )
      )
    )
    #Get the max TPM value

heatmaps = lapply(expt_tpms_top_pirs, 
                  function(tpms){
                    
                    if(tpms$experiment != last(expt_tpms_top_pirs)$experiment){
                      #If it is the final element don't remove the row names
                      rownames(tpms$tpm) = c()
                    }
                    #Setting the name if one is not provided
                    title_name = tpms$experiment
                    #Drawing each heatmap
                    ht = Heatmap(tpms$tpm, 
                                 name = 'log(TPM + 1)', 
                                 col = colorRamp2(c(threshold, 
                                                    maxcol/4, 
                                                    maxcol/2, 
                                                    3*maxcol/4, 
                                                    maxcol), 
                                                  viridis(5)),
                                 cluster_rows = FALSE, 
                                 cluster_columns = FALSE,
                                 column_title = paste(title_name),
                                 column_title_gp = gpar(fontsize = heatmap_col_title_fonts),
                                 row_names_gp = gpar(fontsize = heatmap_row_name_fonts),
                                 column_title_rot = 0,
                                 column_names_rot = 0,
                                 column_names_centered = TRUE,
                                 column_names_gp = gpar(fontsize = heatmap_col_name_fonts),
                                 na_col = 'white', 
                                 border = TRUE,
                                 heatmap_legend_param = list(
                                   title = 'log(TPM + 1)', 
                                   at = mround(
                                     c(log1p(threshold), 
                                       seq(0, 
                                           maxcol, 
                                           length.out = 4)[-1]
                                     ), 
                                     base = 0.05),
                                   labels_gp = gpar(fontsize = 10),
                                   title_gp = gpar(fontsize = 10, fontface = "bold")
                                 ),
                                 cell_fun = function(j, i, x, y, width, height, fill) {
                                   if(!is.na(as.matrix(tpms$max_SorL)[i, j])){
                                     ifelse(
                                       as.matrix(tpms$max_SorL)[i, j] == 'S',
                                       grid.points(x, y, pch = 16, size = unit(3, "mm")),
                                       grid.points(x, y, pch = 18, size = unit(4, "mm"))
                                     )
                                   }
                                 }
                    )
                  })

ldg_subfam <- Legend(labels = c('S', 'L'),
                     type = 'points',
                     pch = c(16,18),
                     size = unit.c(unit(2, "mm"), 
                                   unit(3, "mm")),
                     background = SorL_col[c('S','L')],
                     title = 'Subfamily',
                     title_gp = gpar(fontsize = 10, fontface = "bold"))

ht_list = Reduce('+', heatmaps) #To add the list elements together
ht_list <- ha + ht_list
# pdf('tl19-07_pir_SorLhighest_figure2c_heatmap.pdf'
#     , width = 10
#     , height = 4
# )
draw(ht_list,
     row_title_side = 'left',
     column_title = 'Malaria stage',
     column_title_side = 'bottom',
     column_title_gp = gpar(fontsize = 16),
     heatmap_legend_side = 'left',
     ht_gap = unit(0.5, "cm"),
     heatmap_legend_list = list(ldg_subfam))
# dev.off()
```


# Ancestral and rodent-conserved gene expression curves

```{r ancestral_pir_curve}
gene_graph_24h <- function(input = twentyfour_ct_comb, 
                           genevec = cir_id,
                           genename,
                           use_times = FALSE) {
  cir_plot <- input$tpm %>% 
    filter(Geneid %in% genevec) %>% 
    melt(id.vars = 'Geneid', variable.name = 'sample', value.name = 'tpm') %>% 
    mutate(stage = gsub(sample, pattern = '_[[:digit:]]$', replacement = '')) %>%
    mutate(transmission = str_split_fixed(sample, pattern = '_', n = 3)[,1]) %>%
    mutate(diff_count = str_split_fixed(sample, pattern = '_', n = 4)[,3]) %>% 
    mutate(time = str_split_fixed(sample, pattern = '_', n = 3)[,2]) %>% 
    filter(!(time %in% c('sch', 'Unknown'))) %>% 
    group_by(sample, stage, transmission, time, diff_count) %>% 
    dplyr::summarise(sum_tpm = sum(tpm))
  
  #Want it to be in the right order, but the line function won't work with a discrete scale
  order_diff_counts <- c("Early.Rings",
                         "Early.Mid.Rings",
                         "Late.Mid.Rings",
                         "Late.Rings",
                         "Rings.Troph.conversion",
                         "Early.Trophs",
                         "Mid.Trophs",
                         "Late.Trophs")
  
  order_for_plot <- data.frame(order_diff_counts,
                               order = seq(1, 
                                           length(order_diff_counts), 
                                           1))
  cir_plot <- mutate(cir_plot, 
                     order_plot = order_for_plot$order[match(diff_count, 
                                                             order_for_plot$order_diff_counts)])
  if(use_times){
    order_for_plot$order_diff_counts <- times_stages_table$time[match(order_for_plot$order_diff_counts,
                                                                      times_stages_table$r_stage_diff_count)]
  }
  
  p <- ggplot(data = cir_plot, 
              aes(x = order_plot, 
                  y = sum_tpm,
                  fill = transmission)) +
    stat_summary(fun.y = median, fun.ymin = median, fun.ymax = median,
                 geom = "bar", width = 0.75, size = 0.25, position = 'dodge') +
    geom_point(stat = 'identity', position = position_dodge(width = 0.75)) +
    geom_smooth(method = 'loess', se = FALSE, color = 'black', aes(linetype = transmission)) +
    scale_fill_manual(values = cbPalette) +
    scale_linetype_manual(values = c('dotted', 'dashed')) +
    scale_x_continuous(breaks = order_for_plot$order, 
                       labels = order_for_plot$order_diff_counts) +
    ylab(as.expression(bquote('Total'~italic(.(genename))~'TPM'))) +
    xlab('Asexual blood stage development cycle') +
    theme_classic() +
    theme(axis.text.x=element_text(angle = 90, vjust = 0.5))
  p
}

gene_graph_24h(genevec = 'PCHAS_0101200',
               genename = 'highly-conserved pir',
               use_times = TRUE)

gene_graph_24h(input = twentyfour_tpm_rescale_nopseudo_t,
               genevec = 'PCHAS_0101200',
               genename = 'highly-conserved pir')

ggsave(gene_graph_24h(genevec = 'PCHAS_0101200',
                      genename = 'highly-conserved pir'),
       filename = 'tl19-07_24hchabaudi_ancestral_expressionbarchartLOESS.pdf')
# gene_graph_24h(genevec = 'PCHAS_0524800',
#                genename = 'rodent-conserved pir')
# ggsave(gene_graph_24h(genevec = 'PCHAS_0524800',
#                       genename = 'rodent-conserved pir'),
#        filename = 'tl19-07_24hchabaudi_rodentpir_expressionbarchartLOESS.pdf')

cir_id_no_anc <- str_subset(cir_id, 
                            pattern = 'PCHAS_0101200', 
                            negate = TRUE)
gene_graph_24h(genevec = cir_id_no_anc,
               genename = 'pir without ancestral or rodent-conserved')

# gene_graph_24h(genevec = 'PCHAS_0420800', 
#                genename = 'rMT his-rich pseudogene')
```

## Expression of major expressed cirs rMT/SBP side-by-side.

_pir_ genes selected by being expressed above 1 TPM in all samples.

Adding in housekeeping genes for comparison:
HSP70 putative  PCHAS_0721000
MSP1 PCHAS_0831300
AMA1 PCHAS_0931000


```{r pirs_side-by-side_figure2c}

housekeeping_genes <- data.frame('HSP70' = 'PCHAS_0721000',
                             'MSP1' = 'PCHAS_0831300',
                             'AMA1' = 'PCHAS_0931000')

cir_housekeeping_id <- c(cir_id, 
                         'PCHAS_0721000',
                         'PCHAS_0831300',
                         'PCHAS_0931000')

cir_plot <- twentyfour_ct_comb$tpm %>% 
  filter(Geneid %in% cir_housekeeping_id) %>%
  melt(id.vars = 'Geneid', 
       variable.name = 'sample', 
       value.name = 'tpm') %>% 
  mutate(
    stage = gsub(sample, pattern = '_[[:digit:]]$', replacement = ''),
    transmission = str_split_fixed(sample, pattern = '_', n = 3)[,1],
    diff_count = str_split_fixed(sample, pattern = '_', n = 4)[,3],
    time = str_split_fixed(sample, pattern = '_', n = 3)[,2],
    subfam = cir_clade_info$clade[match(Geneid, cir_clade_info$Geneid)]
  ) %>% 
  mutate(subfam = ifelse(is.na(subfam), 'ref', subfam)) %>% 
  filter(!(time %in% c('sch.culture', 
                       'Unknown'))) %>% 
  group_by(Geneid) %>% 
  filter(any(tpm > 100)) %>% 
  mutate(subfam = str_replace(subfam, 
                              'ancestral',
                              'a'))

cir_plot$Geneid <- ifelse(
  cir_plot$Geneid %in% housekeeping_genes[1,],
  colnames(housekeeping_genes)[ match(cir_plot$Geneid, housekeeping_genes[1,]) ],
  cir_plot$Geneid
)

cir_plot_order <- cir_plot %>% 
  filter(time == '14h',
         transmission == 'rMT') %>% 
  arrange(desc(tpm))


cir_plot <- mutate(cir_plot, 
                   Geneid = factor(Geneid, 
                                   levels = unique(cir_plot_order$Geneid)))
limits_cir <- c(0, mround(max(cir_plot$tpm), base = 100))

side_by_side_cir_plot <- function(time_vec = '11h',
                                  log_it = TRUE,
                                  save = TRUE,
                                  limits = limits_cir,
                                  point_size = 1){
    
    cir_plot <- filter(cir_plot, 
                       time == time_vec)
    
    # cir_plot %>% group_by(Geneid) %>% summarise(n())
    if(log_it){
      cir_plot$tpm <- log1p(cir_plot$tpm)
      limits = log1p(limits)
      breaks <- round(seq.int(0, 
                              max(limits), 
                              length.out = round(max(limits)) + 1, 
                              digits = 0), 
                      digits = 0)
    }else{
      breaks <- seq.int(0, max(limits), length.out = 11)
    }
    
    cir_plot$Geneid <- factor(
      str_remove(cir_plot$Geneid, 
                 pattern = 'PCHAS_'),
      levels = str_remove(levels(cir_plot$Geneid), 
                          pattern = 'PCHAS_')
    )
    
    cir_plot$subfam <- factor(
      cir_plot$subfam,
      levels = c(
        sort(unique(cir_plot$subfam)[!(unique(cir_plot$subfam) %in% 'ref')]),
        'ref'
      )
    )
    
    y <- ggplot(
      data = cir_plot,
      mapping = aes(
        x = Geneid,
        fill = transmission,
        y = tpm
      )
    ) +
      stat_summary(fun.y = median, 
                   fun.ymin = median, 
                   fun.ymax = median,
                   geom = "bar", 
                   width = 0.75, 
                   size = 0.25, 
                   position = 'dodge') +
      geom_point(stat = 'identity', 
                 position = position_dodge(width = 0.75),
                 size = point_size) +
      scale_y_continuous(breaks = breaks,
                         limits = limits) +
      facet_grid(.~subfam, 
                 scales = "free_x",
                 space = "free_x") +
      theme_classic() +
      theme(
        axis.text.x = element_text(angle = 90)
      ) +
      ylab('log(TPM + 1)')+
      ggtitle(paste(unique(cir_plot$time)))
    if(save){
      ggsave2(
        paste0('tl20-05_side-by-side_barchart_facetbySubfam_',
               time_vec,
               '.png'),
        plot = y,
        dpi = 300,
        width = 28,
        height = 8,
        units = 'cm'
      )
    }
    return(y)
  }
  
  lapply(
    sort(unique(cir_plot$time)),
    side_by_side_cir_plot
  )
  
```

## Expression of the S7 pirs.

```{r pirs_side-by-side_different_criteria}

  cir_plot <- twentyfour_ct_comb$tpm %>% 
    filter(Geneid %in% cir_id) %>%
    melt(id.vars = 'Geneid', 
         variable.name = 'sample', 
         value.name = 'tpm') %>% 
    mutate(stage = gsub(sample, pattern = '_[[:digit:]]$', replacement = ''),
           transmission = str_split_fixed(sample, pattern = '_', n = 3)[,1],
           diff_count = str_split_fixed(sample, pattern = '_', n = 4)[,3],
           time = str_split_fixed(sample, pattern = '_', n = 3)[,2],
           subfam = cir_clade_info$clade[match(Geneid, cir_clade_info$Geneid)]) %>% 
    filter(!(time %in% c('sch', 
                         'Unknown'))) %>% 
    group_by(Geneid)

  
  breaks = c(7,6,5,4, 3, 2, 1, 0)
  limits = c(0,7.2)
  point_size = 0.25

  lapply(sort(unique(cir_plot$subfam)),
  function(subfam_nam){
    cir_plot <- cir_plot %>% 
      filter(
        # all(tpm < 100),
        #      any(tpm > 50)
        subfam == subfam_nam
      ) %>% 
      arrange(desc(tpm)) 
    
    cir_plot_order <- cir_plot %>% 
      filter(time == '14h',
             transmission == 'rMT') %>% 
      arrange(desc(tpm))
    
    cir_plot <- mutate(cir_plot, 
                       Geneid = factor(Geneid, 
                                       levels = unique(cir_plot_order$Geneid)))
    
    lapply(
      sort(unique(cir_plot$time)),
      function(time_vec){
        
        cir_plot <- filter(cir_plot, 
                           time == time_vec)
        
      cir_plot$tpm <- log1p(cir_plot$tpm)
      
      cir_plot$Geneid <- factor(
        str_remove(cir_plot$Geneid, 
                   pattern = 'PCHAS_'),
        levels = str_remove(levels(cir_plot$Geneid), 
                            pattern = 'PCHAS_')
      )
      
      y <- ggplot(
        data = cir_plot,
        mapping = aes(
          x = Geneid,
          fill = transmission,
          y = tpm
        )
      ) +
        stat_summary(fun.y = median, 
                     fun.ymin = median, 
                     fun.ymax = median,
                     geom = "bar", 
                     width = 0.75, 
                     size = 0.25, 
                     position = 'dodge') +
        geom_point(stat = 'identity', 
                   position = position_dodge(width = 0.75),
                   size = point_size) +
        scale_y_continuous(breaks = breaks,
                           limits = limits) +
        ylab('ln(TPM + 1)')+
        facet_grid(.~subfam, 
                   scales = "free_x",
                   space = "free_x") +
        theme_classic() +
        theme(
          axis.text.x = element_text(angle = 90,
                                     size = 5)
        ) +
        ggtitle(paste(unique(cir_plot$time)))
      
      ggsave2(
        paste0('tl20-05_side-by-side_barchart_',
               subfam_nam,
               '_',
               time_vec,
               '.png'),
        plot = y,
        dpi = 300,
        width = 25,
        height = 10,
        units = 'cm'
      )
      return(y)
    })
})

```

## Total pir expression in each family across time.

```{r pir_family_expression}

  cir_plot <- twentyfour_ct_comb$tpm %>% 
    filter(Geneid %in% cir_id) %>%
    melt(id.vars = 'Geneid', 
         variable.name = 'sample', 
         value.name = 'tpm') %>% 
    mutate(stage = gsub(sample, pattern = '_[[:digit:]]$', replacement = ''),
           transmission = str_split_fixed(sample, pattern = '_', n = 3)[,1],
           diff_count = str_split_fixed(sample, pattern = '_', n = 4)[,3],
           time = str_split_fixed(sample, pattern = '_', n = 3)[,2],
           subfam = cir_clade_info$clade[match(Geneid, cir_clade_info$Geneid)]) %>% 
    filter(!(time %in% c('sch', 
                         'Unknown'))) %>% 
    group_by(subfam, 
             time,
             transmission,
             sample) %>% 
    summarise(
      sum_tpm = sum(tpm)
    )

  breaks = seq.int(0, mround(max(cir_plot$sum_tpm), base = 100), length.out = 11)
    limits = c(0, mround(max(cir_plot$sum_tpm), base = 100))
    point_size = 0.25

  lapply(sort(unique(cir_plot$subfam)), 
         function(subfam_nam){
           
  # cir_plot_order <- cir_plot %>% 
  #   filter(time == '14h',
  #          transmission == 'rMT') %>% 
  #   arrange(desc(tpm))
  #   
  # cir_plot <- mutate(cir_plot, 
  #                    Geneid = factor(Geneid, 
  #                                    levels = unique(cir_plot_order$Geneid)))
     
    cir_plot <- filter(cir_plot, 
                       subfam == subfam_nam)
 
      # cir_plot$tpm <- log1p(cir_plot$sum_tpm)
    
    y <- ggplot(
      data = cir_plot,
      mapping = aes(
        x = time,
        fill = transmission,
        y = sum_tpm
      )
    ) +
    stat_summary(fun.y = median, 
                 fun.ymin = median, 
                 fun.ymax = median,
                 geom = "bar", 
                 width = 0.75, 
                 size = 0.25, 
                 position = 'dodge') +
    geom_point(stat = 'identity', 
               position = position_dodge(width = 0.75),
               size = point_size) +
    scale_y_continuous(breaks = breaks,
                       limits = limits) +
    theme_classic() +
    theme(
      axis.text.x = element_text(angle = 90,
                                 size = 5)
    ) +
    ggtitle(subfam_nam)

    ggsave2(
      paste0('tl20-05_total-expression_by-subfam_',
             subfam_nam,
             '.png'),
      plot = y,
      dpi = 300,
      width = 25,
      height = 10,
      units = 'cm'
    )
  return(y)
  })
```


# Pir expression of AAPLs and ChAPLs.

```{r AapL-ChaAPl_expression}

  cir_plot <- twentyfour_ct_comb$tpm %>% 
    filter(Geneid %in% cir_id) %>%
    melt(id.vars = 'Geneid', 
         variable.name = 'sample', 
         value.name = 'tpm') %>% 
    mutate(stage = gsub(sample, pattern = '_[[:digit:]]$', replacement = ''),
           transmission = str_split_fixed(sample, pattern = '_', n = 3)[,1],
           diff_count = str_split_fixed(sample, pattern = '_', n = 4)[,3],
           time = str_split_fixed(sample, pattern = '_', n = 3)[,2],
           subfam = cir_clade_info$clade[match(Geneid, cir_clade_info$Geneid)],
           chapl_aapl = factor(cir_chapl_aapl_info$chapl_aapl[match(Geneid, 
                                                                    cir_chapl_aapl_info$Geneid)],
                               levels = sort(unique(cir_chapl_aapl_info$chapl_aapl[match(Geneid, 
                                                                                         cir_chapl_aapl_info$Geneid)])))) %>% 
    filter(!(time %in% c('sch', 
                         'Unknown')),
           !is.na(chapl_aapl) ) %>% 
    group_by(Geneid) %>% 
    # filter(
    #   # all(tpm < 100),
    #   #      any(tpm > 50)
    #   subfam == 'S7'
    #   ) %>% 
    arrange(desc(tpm)) 
  
  cir_plot_order <- cir_plot %>% 
    filter(time == '14h',
           transmission == 'SBP') %>% 
    arrange(desc(tpm))
    
  cir_plot <- mutate(cir_plot, 
                     Geneid = factor(Geneid, 
                                     levels = unique(cir_plot_order$Geneid)))
  
  breaks = c(7,6,5,4, 3, 2, 1, 0)
    limits = c(0,7)
    point_size = 0.25
  
  lapply(
    sort(unique(cir_plot$time)),
    function(time_vec){
    
    cir_plot <- filter(cir_plot, 
                       time == time_vec)
 
      cir_plot$tpm <- log1p(cir_plot$tpm)
    
    cir_plot$Geneid <- factor(
      str_remove(cir_plot$Geneid, 
                 pattern = 'PCHAS_'),
      levels = str_remove(levels(cir_plot$Geneid), 
                          pattern = 'PCHAS_')
    )
    
    y <- ggplot(
      data = cir_plot,
      mapping = aes(
        x = Geneid,
        fill = transmission,
        y = tpm
      )
    ) +
    stat_summary(fun.y = median, 
                 fun.ymin = median, 
                 fun.ymax = median,
                 geom = "bar", 
                 width = 0.75, 
                 size = 0.25, 
                 position = 'dodge') +
    geom_point(stat = 'identity', 
               position = position_dodge(width = 0.75),
               size = point_size) +
    scale_y_continuous(breaks = breaks,
                       limits = limits) +
    facet_grid(.~chapl_aapl, 
             scales = "free_x",
             space = "free_x") +
    theme_classic() +
    theme(
      axis.text.x = element_text(angle = 90,
                                 size = 5)
    ) +
    ggtitle(paste(unique(cir_plot$time)))

    ggsave2(
      paste0('tl20-05_side-by-side_barchart_chapl_aapl_',
             time_vec,
             '.png'),
      plot = y,
      dpi = 300,
      width = 25,
      height = 10,
      units = 'cm'
    )
  return(y)
})
```


# Pir expression across the genome

```{r pirs_across_genome}

  cir_plot <- twentyfour_ct_comb$tpm %>% 
    filter(Geneid %in% cir_id) %>%
    melt(id.vars = 'Geneid', 
         variable.name = 'sample', 
         value.name = 'tpm') %>% 
    mutate(
      stage = gsub(sample, pattern = '_[[:digit:]]$', replacement = ''),
      transmission = str_split_fixed(sample, pattern = '_', n = 3)[,1],
      diff_count = str_split_fixed(sample, pattern = '_', n = 4)[,3],
      time = str_split_fixed(sample, pattern = '_', n = 3)[,2],
      subfam = cir_clade_info$clade[match(Geneid, cir_clade_info$Geneid)],
      chrom = paste0('chr',
                     str_extract(Geneid, 
                                 pattern = '(?<=PCHAS_)[[:digit:]]{2}'))
    ) %>% 
  filter(!(time %in% c('sch', 
                       'Unknown')),
         # transmission == 'rMT'
         ) %>% 
  group_by(Geneid)

breaks <- seq.int(0, mround(max(cir_plot$tpm), base = 100), length.out = 6)
limits <- c(0, mround(max(cir_plot$tpm), base = 100))

lapply(sort(unique(cir_plot$time)), 
       function(time_vec){
         cir_plot <- filter(cir_plot, 
                            time == time_vec)
         
           # cir_plot$tpm <- log1p(cir_plot$tpm)
         
         cir_plot$Geneid <- str_remove(cir_plot$Geneid, 
                                       pattern = 'PCHAS_')
         
         y <- ggplot(
           data = cir_plot,
           mapping = aes(
             x = Geneid,
             fill = transmission,
             y = tpm
           )
         ) +
           stat_summary(fun.y = median, 
                        fun.ymin = median, 
                        fun.ymax = median,
                        geom = "bar", 
                        width = 0.75, 
                        size = 0.25, 
                        position = 'dodge') +
           scale_y_continuous(breaks = breaks,
                              limits = limits) +
           scale_fill_manual(
             values = c('rMT' = 'blue', 
                        'SBP' = 'red')
           ) +
           facet_grid(.~chrom,
                    scales = "free_x",
                    space = "free_x") +
           theme_classic() +
           theme(
             axis.text.x = element_blank(),
             axis.ticks.x = element_blank(),
             panel.spacing = unit(0.1, "lines")
           ) +
           ggtitle(paste(unique(cir_plot$time)))

         # ggsave2(
         #   paste0('tl20-05_side-by-side_barchart_genome_facetChrom_',
         #          time_vec,
         #          '.png'),
         #   plot = y,
         #   dpi = 300,
         #   width = 25,
         #   height = 10,
         #   units = 'cm'
         # )
         
         return(y)
       })

```

# How does expression of the different clades change with time?

```{r clade_with-time_graph}
cir_plot <- twentyfour_ct_comb$tpm %>% 
  filter(Geneid %in% cir_id_no_anc_or_rodcon) %>% 
  melt(id.vars = 'Geneid', variable.name = 'sample', value.name = 'tpm') %>% 
  mutate(stage = gsub(sample, pattern = '_[[:digit:]]$', replacement = '')) %>%
  mutate(transmission = str_split_fixed(sample, pattern = '_', n = 3)[,1]) %>%
  mutate(diff_count = str_split_fixed(sample, pattern = '_', n = 4)[,3]) %>% 
  mutate(time = str_split_fixed(sample, pattern = '_', n = 3)[,2]) %>% 
  filter(!(time %in% c('sch', 'Unknown'))) %>% 
  mutate(clade = reid_cir_clade$clade[match(Geneid, reid_cir_clade$Geneid)]) %>% 
  group_by(clade, transmission, time, diff_count) %>% 
  dplyr::summarise(median_tpm = median(tpm),
                   sd_tpm = sd(tpm),
                   n = n_distinct(Geneid))

# group_by(reid_cir_clade, clade) %>% 
#   dplyr::summarise(n())
# 
# cir_id[which(!(cir_id %in% reid_cir_clade$Geneid))]

order_diff_counts <- c("Early.Rings",
                       "Early.Mid.Rings",
                       "Late.Mid.Rings",
                       "Late.Rings",
                       "Rings.Troph.conversion",
                       "Early.Trophs",
                       "Mid.Trophs",
                       "Late.Trophs")
cir_plot$diff_count <- factor(cir_plot$diff_count, levels  = order_diff_counts)

p <- ggplot(data = cir_plot, 
            aes(x = diff_count, 
                y = log1p(median_tpm),
                fill = clade)) +
  geom_col(position = position_dodge()) +
  scale_fill_manual(values = cbPalette) +
  ylab(as.expression(bquote('Median'~italic('pir')~'log TPM + 1 by clade'))) +
  theme_classic() +
  theme(axis.text.x=element_text(angle = 90, vjust = 0.5)) + 
  facet_grid(. ~ transmission)
p

cir_plot <- twentyfour_ct_comb$tpm %>% 
  filter(Geneid %in% cir_id) %>% 
  melt(id.vars = 'Geneid', variable.name = 'sample', value.name = 'tpm') %>% 
  mutate(stage = gsub(sample, pattern = '_[[:digit:]]$', replacement = '')) %>%
  mutate(transmission = str_split_fixed(sample, pattern = '_', n = 3)[,1]) %>%
  mutate(diff_count = str_split_fixed(sample, pattern = '_', n = 4)[,3]) %>% 
  mutate(time = str_split_fixed(sample, pattern = '_', n = 3)[,2]) %>% 
  filter(!(time %in% c('sch', 'Unknown'))) %>% 
  mutate(clade = reid_cir_clade$clade[match(Geneid, reid_cir_clade$Geneid)]) %>% 
  mutate(clade = ifelse(grepl(clade, pattern = 'L'), 'Long', 
                        ifelse(grepl(clade, pattern = 'S'), 'Short',
                               'Unk'))) %>% 
  filter(clade != 'Unk')

order_diff_counts <- c("Early.Rings",
                       "Early.Mid.Rings",
                       "Late.Mid.Rings",
                       "Late.Rings",
                       "Rings.Troph.conversion",
                       "Early.Trophs",
                       "Mid.Trophs",
                       "Late.Trophs")
cir_plot$diff_count <- factor(cir_plot$diff_count, levels  = order_diff_counts)

p <- ggplot(data = cir_plot, 
            aes(x = diff_count,
                y = log1p(tpm),
                fill = clade,
                col = transmission)) +
  # geom_col(position = position_dodge()) +
  geom_boxplot() +
  scale_fill_manual(values = cbPalette) +
  scale_color_manual(values = c('dark blue','dark red')) +
  xlab('Stage') +
  ylab(as.expression(bquote('Median'~italic('pir')~'log TPM + 1 by clade'))) +
  theme_classic() +
  theme(axis.text.x=element_text(angle = 90, vjust = 0.5))
p

```

The only time that the SBP pir genes are being expressed higher than rMT are the burst of Short-forms in the Early Ring stage.

Splitting the _pir_ TPM graphs into S or L clades, and the sub-clades.

```{r total_tpm_pir_clades}
pir_clade_list <- lapply(unique(reid_cir_clade$clade), function(clade_name){
  reid_cir_clade$Geneid[reid_cir_clade$clade %in% clade_name]
})
names(pir_clade_list) <- as.character(unique(reid_cir_clade$clade))

#c can cat lists too!

total_tpm_expression(pir_clade_list, 
                     save = FALSE)
```

L4s and L1s appear to be particularly high in the rMT samples.

```{r total_tpm_pir_clades_SorL}
pir_SorL <- lapply(c('S','L'), function(clade_name){
  reid_cir_clade$Geneid[grepl(reid_cir_clade$clade, pattern = clade_name)]
})
names(pir_SorL) <- c('S','L')
total_tpm_expression(pir_SorL, save = FALSE)
```

#Expression of pirs from different chromosomes.

```{r total_tpm_pir_chrom}
pir_chrom_list <- lapply(unique(cir_chrom_tbl$chrom), 
                         function(chrom_name){
  cir_chrom_tbl$Geneid[cir_chrom_tbl$chrom %in% chrom_name]
})
names(pir_chrom_list) <- as.character(
  paste0(
    'chromosome ',
    unique(cir_chrom_tbl$chrom)
  )
)

total_tpm_expression(pir_chrom_list, save = FALSE)
```

Many big differences across the chromosomes. I wonder if this is consistent with Spence 2013 and Brugat 2017 data?

Early rings: Chr01/07/08/09/10 expressed higher in SBP. Chr05 expressed higher in SBP.

# Looking at the ETRAMP family which shows interesting expression patterns

```{r etramps}
etramp_info <- chabaudi_gene_info %>% 
  select(Geneid, Description, Transcript.Length) %>% 
  filter(Description == 'early transcribed membrane protein')
etramps <- unique(etramp_info$Geneid)

draw_heatmap_chabaudi_24h(datasets = twentyfour_ct, 
                          genelist = etramps,
                          scale = 'max',
                          threshold = 0,
                          log_it = TRUE)
gene_graph_24h(genevec = etramps, genename = 'ETRAMPs')

twentyfour_ct_etramps <- twentyfour_ct_comb$tpm %>% 
  filter(Geneid %in% etramps) %>% 
  melt(id.vars = 'Geneid', variable.name = 'sample', value.name = 'tpm') %>% 
  mutate(stage = gsub(sample, pattern = '_[[:digit:]]$', replacement = '')) %>%
  mutate(transmission = str_split_fixed(sample, pattern = '_', n = 3)[,1]) %>%
  mutate(time = str_split_fixed(sample, pattern = '_', n = 3)[,2]) %>% 
  #Convert the times given in 'h' to robustly coded times in 24h clock
  mutate(time = ifelse(grepl(time, pattern = '[[:digit:]]h$'), 
                       strptime(time, format="%Hh") %>% format(., "%Hh"),
                       time)) %>% 
  mutate(time = ifelse(grepl(time, pattern = '[[:digit:]](a|p)m'), 
                       strptime(time, format="%I%p") %>% format(., "%Hh"),
                       time)) %>% 
  group_by(sample, stage, transmission, time) %>% 
  dplyr::summarise(sum_tpm = sum(tpm))

p <- ggplot(data = twentyfour_ct_etramps, aes(x = time, 
                                          y = log1p(sum_tpm),
                                          fill = transmission)) +
  stat_summary(fun.y = median, fun.ymin = median, fun.ymax = median,
               geom = "bar", width = 0.75, size = 0.25, position = 'dodge') +
  geom_point(stat = 'identity', position = position_dodge(width = 0.75)) +
  scale_fill_manual(values = cbPalette) +
  theme(axis.text.x=element_text(angle = 90, vjust = 0.5)) +
  theme_classic() + 
  ggtitle('24h chabaudi etramp expression')
p
```

When one ETRAMP goes down, does another replace it?

# Expression of HSP70

Often used as a housekeeping gene.

```{r hsp70}
total_tpm_expression(list_genes=list(hsp70 = 'PCHAS_0721000'),
                     save = TRUE)
```


# Calculate and cluster with z-scores {.tabset}

z-score represents the number of standard deviations from the mean of the data. To calculate from TPM or counts for a given gene X:

1. Convert the count/RPKM values of each gene into log values.
2. Calculate the mean and standard deviation of X gene log values in each sample
3. For first sample: (gene X log value - mean of log values of samples)/ standard deviation of log values of all samples
4. Now. i have the z-score for gene x in first sample. Using the above protocol, I can convert all genes log values into z-score.

* Need to make sure that the z-score is calculated within each transmission method!

```{r zscores}
tpm_to_zscore = function(input){
  
  #Can use vars(matches(paste(input$experiment))) to get the columns with expression data
  # input_logged = input$tpm %>% 
  #   mutate_at(vars(matches(paste(input$experiment))), log1p)
  
  #If the input does not have a TPM element then assume that the input itself is the TPM object
  if(any(names(input) %in% 'tpm')){
    tpm_object <- input$tpm
  }else{
    tpm_object <- input
    warning('No \'tpm\' element in the supplied input so function will assume that the input is the tpm data')
  }
  
  #Want all of them so will just ignore Geneid
  input_logged = tpm_object %>%
    mutate_at(vars(-matches('Geneid')), 
              log1p)
  
  gene_mean_scores = input_logged %>% 
    melt(id.vars = 'Geneid') %>% 
    group_by(Geneid) %>% 
    dplyr::summarise(mean = mean(value),
                     std_dev = sd(value))
  
  gene_vector = as.character(input_logged$Geneid)
  
  input_z = lapply(gene_vector, function(gene){
    mean_gene = filter(gene_mean_scores, 
                       Geneid == paste(gene)) %>% 
      select(mean)
    std_gene = filter(gene_mean_scores, 
                      Geneid == paste(gene)) %>% 
      select(std_dev)
    gene_scores = input_logged %>% 
      filter(Geneid == paste(gene)) %>% 
      select(-Geneid)
    if(std_gene != 0){
      gene_z = sapply(gene_scores, function(score){(score-mean_gene)/std_gene}) %>% data.frame
    }else{
      gene_z = (sapply(gene_scores, function(score){0})) %>% data.frame %>% t
    }
    colnames(gene_z) = colnames(gene_scores) #For some reason apply makes the column names weird
    gene_z = cbind(data.frame(Geneid = paste(gene)), gene_z)
  })
  
  #Use reduce and rbind to turn the list into one df
  input_z_df = purrr::reduce(input_z, 
                             rbind)
  return(list(zscores = input_z_df,
              tpm = tpm_object,
              experiment = input$experiment))
}

#Make and save z-scores
# twentyfour_z <- lapply(twentyfour_ct, 
# tpm_to_zscore)

### Calculate and write zscores

# twentyfour_z <- lapply(twentyfour_avgtpm_noschz,
#                        tpm_to_zscore)
# 
# lapply(twentyfour_z, function(list_element){
#   z_df <- list_element$zscore
#   write_csv(x = z_df,
#             paste0('tl19-07_chabaudi24h_', list_element$experiment, '.csv'))
# })

###

### Read z-scores

twentyfour_z <- list(
  'rMT' = list(zscores = read_csv('tl19-07_chabaudi24h_rMT.csv'),
               tpm = twentyfour_avgtpm_noschz$rMT$tpm,
               experiment = 'rMT'),
  'SBP' = list(zscores = read_csv('tl19-07_chabaudi24h_SBP.csv'),
               tpm = twentyfour_avgtpm_noschz$SBP$tpm,
               experiment = 'SBP')
)

###
```

## Looking at all genes which have a z score over 2.4

```{r over2z}
over2_z_genes <- lapply(twentyfour_z, function(list_experiments){
  list_experiments$zscores %>%  
  filter_at(vars(-matches('Geneid')), 
            any_vars(. > 2.4)) %>% 
  .$Geneid
})

draw_heatmap_chabaudi_24h(datasets = twentyfour_ct, 
                          genelist = unlist(over2_z_genes),
                          scale = 'max',
                          threshold = 0,
                          log_it = FALSE)
```

Hmm so the largest z scores aren't necessarily the most variable according to the correlation plot? Is this because they often only vary greatly in one sample?

# Phaseograms of the data. {.tabset}

```{r row_order_phaseograms}

#Getting the row order for each phaseogram for each experiment
# Want the data ordered by the highest zscore for each gene in each stage.
phaseogram_row_order <- lapply(twentyfour_z, 
                               function(list_elements){
                                 zscore_df <- list_elements$zscores
                                 zscore_ordered <- melt(zscore_df, 
                                                        id = 'Geneid',
                                                        variable.name = 'stage',
                                                        value.name = 'zscore') %>% 
                                   group_by(Geneid) %>% 
                                   top_n(zscore, n = 1) %>% 
                                   arrange(stage, 
                                           desc(zscore)) %>%
                                   distinct(Geneid, 
                                            .keep_all = TRUE) %>%  #Keep only the ones that are uniquely highest expressed in one sample
                                   filter(zscore > 0) #For some reason some remain with zero zscore
                                 zscore_ordered <- zscore_ordered[order(
                                   match(
                                     zscore_ordered$stage, 
                                     order_vector
                                   )
                                 ),]
                                 return(c(list_elements, 
                                          list(zscore_order = zscore_ordered)))
                               })

phaseogram_time_order <- lapply(names(phaseogram_row_order), 
                                function(list_element){
                                  transmission_list <- getElement(phaseogram_row_order,
                                                                  list_element)
                                  order_by_time <- transmission_list$zscore_order %>% 
                                    mutate(stage = times_stages_table$time[match(stage,
                                                                                 times_stages_table$r_stage_diff_count)]) %>% 
                                    arrange(stage)
                                  return(list(zscore_order = order_by_time))
                                }
)
names(phaseogram_time_order) <- names(phaseogram_row_order)


```

~~Change the lnTPM graph to a heatmap of max/min TPM a la Brugat 2017.~~

~~Add annotation for the clades,~~ or possibly separate the heatmap by clade.

Add threshold option.

```{r function_draw_heatmap_zscore}

draw_heatmap_zscore <- function(zscore_list,
                                title = '',
                                gene_ordering_vector = NULL,
                                filter_genes_vector = NULL,
                                extra_title = NULL,
                                annotation_clade = NULL,
                                annotation_col,
                                threshold_tpm = NULL,
                                use_times = FALSE,
                                use_order_vector = TRUE,
                                tpm_mat = TRUE,
                                tpm_breaks = NULL,
                                ...){
  if(is.null(tpm_breaks) & tpm_mat){
    #Need the generate the breaks in the data for the heatmap legend if not provided.
    max_tpm <- lapply(zscore_list, 
                      function(list_element){
                        #list_element <- zscore_list[[1]]
                        heatmap_data <- as.data.frame(list_element$zscores)
                        title <- list_element$experiment
                        
                        if(!'Geneid' %in% colnames(heatmap_data)){
                          stop('No Geneid column in the heatmap data.frame')
                        }
                        
                        if(!is.null(filter_genes_vector)){
                          heatmap_data <- as.data.frame(
                            filter(heatmap_data, 
                                   Geneid %in% filter_genes_vector)
                          )
                        }
                        
                        rownames(heatmap_data) <- as.character(heatmap_data$Geneid)
                        
                        heatmap_data <- heatmap_data[, !colnames(heatmap_data) %in% 'Geneid', drop = TRUE]
                        #This won't work if heatmap_data is a tibble, must be a data.frame, so annoying!!
                        
                        if(!is.null(gene_ordering_vector)){
                          #Remove genes not in the main data frame but in the ordering vector, 
                          # and then order based on the vector
                          remove_index <- rownames(heatmap_data) %in% gene_ordering_vector
                          heatmap_data <- heatmap_data[remove_index,,drop = FALSE]
                          heatmap_data <- heatmap_data[na.omit(
                            match(gene_ordering_vector, 
                                  rownames(heatmap_data))
                          ),,
                          drop=FALSE]
                        }
                        
                        geneids <- rownames(heatmap_data)
                        
                        #Get max/min TPM scores for the side annotation heatmap                       
                        tpm_mat <- list_element$tpm[match(rownames(heatmap_data),
                                                          list_element$tpm$Geneid),] %>% 
                          select(-Geneid) %>% 
                          as.matrix %>% 
                          log1p
                        rownames(tpm_mat) <- geneids
                        
                        tpm_min <- rowMins(tpm_mat)
                        names(tpm_min) <- geneids
                        tpm_max <- rowMaxs(tpm_mat)
                        names(tpm_max) <- geneids
                        return(list(tpm_max = tpm_max,
                                    tpm_min = tpm_min))
                      })
    
    tpm_max_all <- mround(
      max(
        unlist(
          lapply(max_tpm, 
                 getElement,
                 'tpm_max')
        )
      ), 
      base = 1)
    
    tpm_breaks <- round(
      c(0,
        tpm_max_all/4,
        tpm_max_all/2,
        tpm_max_all*(3/4),
        tpm_max_all),
      digits = 2
    )
  }
  
  #Generate the colour function from the TPM legend breaks for the TPM annotation
  if(tpm_mat){
    tpm_col_fun <- colorRamp2(
      breaks = tpm_breaks,
      colors = viridis(length(tpm_breaks))
    )
  }
  
  if(is.numeric(threshold_tpm)){
    #Apply a threshold to the TPM in order to remove low expressed genes.
    # Remember to add log1p here! 
    # Threshold uses the max value, so it ony needs to be above thresh 
    #   in one stage avg in one transmission method.
    #Will alter the gene_filter vector in order to only select the genes above threshold
    
    gene_maxs <- bind_rows(
      lapply(max_tpm, 
             getElement,
             'tpm_max')
    )
    
    remove_genes <- names(gene_maxs)[apply(
      gene_maxs, 
      2, 
      function(maxs){
        all(maxs < log1p(threshold_tpm))
      }
    )]
    
    filter_genes_vector <- filter_genes_vector[!filter_genes_vector %in% remove_genes]
    
  }
  
  if(is.character(annotation_clade)){
    order_cir <- gene_ordering_vector[gene_ordering_vector %in% filter_genes_vector]
    clade_info <- getElement(cir_clade_info,
                             annotation_clade)[match(order_cir, 
                                                     cir_clade_info$Geneid)]
    names(clade_info) <- str_split_fixed(order_cir, 
                                         pattern = '_', 
                                         n = 2)[,2]
    annotation_col <- annotation_col
  }
  
  heatmaps <- lapply(zscore_list, 
                     function(list_element){
                       #list_element <- zscore_list[[1]]
                       heatmap_data <- as.data.frame(list_element$zscores)
                       title <- list_element$experiment
                       
                       if(!'Geneid' %in% colnames(heatmap_data)){
                         stop('No Geneid column in the heatmap data.frame')
                       }
                       
                       if(!is.null(filter_genes_vector)){
                         heatmap_data <- as.data.frame(
                           filter(heatmap_data, 
                                  Geneid %in% filter_genes_vector)
                         )
                       }
                       
                       rownames(heatmap_data) <- as.character(heatmap_data$Geneid)
                       
                       heatmap_data <- heatmap_data[, !colnames(heatmap_data) %in% 'Geneid', drop = TRUE]
                       #This won't work if heatmap_data is a tibble, must be a data.frame, so annoying!!
                       
                       if(!is.null(gene_ordering_vector)){
                         #Remove genes not in the main data frame but in the ordering vector,
                         #  and then order based on the vector
                         remove_index <- rownames(heatmap_data) %in% gene_ordering_vector
                         heatmap_data <- heatmap_data[remove_index,,drop = FALSE]
                         heatmap_data <- heatmap_data[na.omit(
                           match(gene_ordering_vector, 
                                 rownames(heatmap_data))
                         ),,
                         drop=FALSE]
                       }
                       
                       if(tpm_mat){
                         #Get max/min TPM scores for the side annotation heatmap                       
                         tpm_mat <- list_element$tpm[match(rownames(heatmap_data),
                                                           list_element$tpm$Geneid),] %>%
                           select(-Geneid) %>% 
                           as.matrix %>% 
                           log1p
                         
                         tpm_min <- rowMins(tpm_mat)
                         tpm_max <- rowMaxs(tpm_mat)
                         
                         names(tpm_min) = rownames(heatmap_data)
                         names(tpm_max) = rownames(heatmap_data)
                         
                         tpm_ha <- rowAnnotation(
                           min.max = anno_simple(cbind(tpm_min, 
                                                       tpm_max), 
                                                 col = tpm_col_fun,
                                                 gp = gpar(col = 'black',
                                                           lwd = 0.1),
                                                 border = TRUE,
                                                 simple_anno_size = unit(0.2, "cm")),
                           show_annotation_name = FALSE)
                       }
                       
                       #Draw the left annotation is needed, only for the first element.
                       
                       if(
                         identical(list_element,
                                   first(zscore_list)) & is.character(annotation_clade)
                       ){
                         clade_ha <- rowAnnotation(
                           'subfamily' = anno_simple(
                             clade_info,
                             col = annotation_col
                           )
                         )
                       }
                       
                       #Change rownames to remove PCHAS_
                       rownames(heatmap_data) = str_split_fixed(rownames(heatmap_data), 
                                                                pattern = '_', 
                                                                n = 2)[,2]
                       
                       if(use_times){
                         colnames(heatmap_data) <- times_stages_table$time[match(colnames(heatmap_data),
                                                                                 times_stages_table$r_stage_diff_count)]
                       }
                       
                       if(use_order_vector){
                         #Order the columns by ordering_vector
                         heatmap_data <- heatmap_data[,order(match(colnames(heatmap_data), 
                                                                   order_vector)),
                                                      drop = FALSE]
                       }else{
                         heatmap_data <- heatmap_data[,order(colnames(heatmap_data)),
                                                      drop = FALSE] 
                       }
                       
                       h = Heatmap(heatmap_data,
                                   name = paste0('z-score',
                                                 extra_title),
                                   col = c(cbPalette[6],
                                           'white', 
                                           cbPalette[7]),
                                   row_names_gp = gpar(fontsize = ifelse(
                                     nrow(heatmap_data) > 13, 
                                     12*(13/nrow(heatmap_data)), 
                                     12)
                                   ),
                                   column_names_gp = gpar(fontsize = 10),
                                   row_dend_width = unit(3, "cm"),
                                   right_annotation = if(tpm_mat){
                                     tpm_ha
                                   }else{
                                     NULL
                                   },
                                   left_annotation = 
                                     if(identical(list_element,
                                                  first(zscore_list)) & is.character(annotation_clade)){
                                       clade_ha
                                     }else{
                                       NULL
                                     }, 
                                   #Only want the clade annotation when it is first heatmap
                                   width = unit(4.5, 'cm'),
                                   cluster_columns = FALSE,
                                   height = unit(7,'cm'),
                                   row_title = NULL,
                                   cluster_rows = FALSE,
                                   column_title = paste(title),
                                   heatmap_legend_param = list(
                                     at = c(3,2,1,0,-1,-2,-3),
                                     labels_gp = gpar(fontsize = 10),
                                     title_gp = gpar(fontsize = 10)
                                   ),
                                   ...
                       )
                       return(h)
                     })
  
  ht_list <- Reduce('+', heatmaps) #To add the list elements together
  
  if(tpm_mat){
    #Draw the legend
    tpm_lgd <- Legend(
      title = "Min/Max log(TPM + 1)", 
      col_fun = tpm_col_fun, 
      at = tpm_breaks, 
      labels = tpm_breaks,
      title_gp = gpar(fontsize = 7)
    )
  }
  
  if(is.character(annotation_clade)){
    clade_lgd <- Legend(
      title = 'sub-family',
      at = names(annotation_col),
      legend_gp = gpar(fill = annotation_col)
    )
  }
  
  draw(ht_list, 
       row_title_side = 'left',
       column_title_side = 'bottom',
       heatmap_legend_side = 'left',
       #Only include the annotation legends for the annotations we actually have.
       annotation_legend_list = if(is.character(annotation_clade) & tpm_mat){
         list(tpm_lgd,
              clade_lgd)
       }else if(tpm_mat & !is.character(annotation_clade) ){
         list(tpm_lgd)
       } else if(!tpm_mat & is.character(annotation_clade) ){
         list(clade_lgd)
       })
}
```

## Phaseograms of the entire genome.

```{r phaseograms_whole_genome}
draw_heatmap_zscore(zscore_list = twentyfour_z,
                    gene_ordering_vector = phaseogram_time_order$rMT$zscore_order$Geneid,
                    use_times = TRUE,
                    use_order_vector = FALSE,
                    show_row_names = FALSE,
                    tpm_mat = FALSE)
```

## Phaseograms of the _cir_ genes with clade annotations.

```{r pir_gene_phaseogram_breaks}
  max_tpm <- lapply(twentyfour_z, 
                    function(list_element){
                      #list_element <- zscore_list[[1]]
                      heatmap_data <- as.data.frame(list_element$zscores)
                      title <- list_element$experiment
                      
                      if(!'Geneid' %in% colnames(heatmap_data)){
                        stop('No Geneid column in the heatmap data.frame')
                      }
                          
                            heatmap_data <- as.data.frame(
                              filter(heatmap_data, 
                                     Geneid %in% cir_id)
                            )
                        
                          rownames(heatmap_data) <- as.character(heatmap_data$Geneid)
                          
                          heatmap_data <- heatmap_data[, !colnames(heatmap_data) %in% 'Geneid', drop = TRUE]
                          #This won't work if heatmap_data is a tibble, must be a data.frame, so annoying!!
                          # 
                          # if(!is.null(gene_ordering_vector)){
                          #   #Remove genes not in the main data frame but in the ordering vector, 
                          #   # and then order based on the vector
                          #   remove_index <- rownames(heatmap_data) %in% gene_ordering_vector
                          #   heatmap_data <- heatmap_data[remove_index,,drop = FALSE]
                          #   heatmap_data <- heatmap_data[na.omit(
                          #     match(gene_ordering_vector, 
                          #           rownames(heatmap_data))
                          #   ),,
                          #   drop=FALSE]
                          # }
                          
                          geneids <- rownames(heatmap_data)
                          
                          #Get max/min TPM scores for the side annotation heatmap                       
                          tpm_mat <- list_element$tpm[match(rownames(heatmap_data),
                                                            list_element$tpm$Geneid),] %>% 
                            select(-Geneid) %>% 
                            as.matrix %>% 
                            log1p
                          rownames(tpm_mat) <- geneids
                          
                          tpm_min <- rowMins(tpm_mat)
                          names(tpm_min) <- geneids
                          tpm_max <- rowMaxs(tpm_mat)
                          names(tpm_max) <- geneids
                          return(list(tpm_max = tpm_max,
                                      tpm_min = tpm_min))
                        })
  
  tpm_max_all <- mround(
    max(
      unlist(
        lapply(max_tpm, 
               getElement,
               'tpm_max')
      )
    ), 
    base = 1)
  
  tpm_breaks <- round(
    c(0,
      tpm_max_all/4,
      tpm_max_all/2,
      tpm_max_all*(3/4),
      tpm_max_all),
    digits = 2
  )
```


```{r phaseograms_cir_order_each}

#Generate the colour function from the TPM legend breaks for the TPM annotation

tpm_col_fun <- colorRamp2(
  breaks = tpm_breaks,
  colors = viridis(length(tpm_breaks))
)

#Apply a threshold to the TPM in order to remove low expressed genes.
# Remember to add log1p here! 
# Threshold uses the max value, so it ony needs to be above thresh 
#   in one stage avg in one transmission method.
#Will alter the gene_filter vector in order to only select the genes above threshold

gene_maxs <- bind_rows(
  lapply(max_tpm, 
         getElement,
         'tpm_max')
)

remove_genes <- names(gene_maxs)[apply(
  gene_maxs, 
  2, 
  function(maxs){
    all(maxs < log1p(1))
  }
)]

filter_genes_vector <- cir_id[!cir_id %in% remove_genes]

heatmaps <- lapply(names(twentyfour_z), 
                   function(list_name){
                     list_element <- getElement(twentyfour_z, 
                                                list_name)
                     #list_name <- names(twentyfour_z)[[1]]
                     heatmap_data <- as.data.frame(list_element$zscores)
                     title <- list_element$experiment
                     
                     heatmap_data <- as.data.frame(
                       filter(heatmap_data, 
                              Geneid %in% filter_genes_vector)
                     )
                     
                     rownames(heatmap_data) <- as.character(heatmap_data$Geneid)
                     
                     heatmap_data <- heatmap_data[, 
                                                  !colnames(heatmap_data) %in% 'Geneid', 
                                                  drop = TRUE]
                     #This won't work if heatmap_data is a tibble, must be a data.frame, so annoying!!
                     
                     #Remove genes not in the main data frame but in the ordering vector,
                     #  and then order based on the vector
                     gene_ordering_vector <- getElement(phaseogram_time_order,
                                                        list_name)$zscore_order$Geneid
                     
                     order_cir <- gene_ordering_vector[gene_ordering_vector %in% filter_genes_vector]
                     clade_info <- getElement(cir_clade_info,
                                              'SorL')[match(order_cir, 
                                                            cir_clade_info$Geneid)]
                     names(clade_info) <- str_split_fixed(order_cir, 
                                                          pattern = '_', 
                                                          n = 2)[,2]
                     annotation_col <- SorL_col
                     
                     remove_index <- rownames(heatmap_data) %in% gene_ordering_vector
                     heatmap_data <- heatmap_data[remove_index,
                                                  ,
                                                  drop = FALSE]
                     heatmap_data <- heatmap_data[na.omit(
                       match(gene_ordering_vector, 
                             rownames(heatmap_data))
                     ),
                     ,
                     drop=FALSE]
                     
                     #Get max/min TPM scores for the side annotation heatmap                       
                     tpm_mat <- list_element$tpm[match(rownames(heatmap_data),
                                                       list_element$tpm$Geneid),] %>%
                       select(-Geneid) %>% 
                       as.matrix %>% 
                       log1p
                     
                     tpm_min <- rowMins(tpm_mat)
                     tpm_max <- rowMaxs(tpm_mat)
                     
                     names(tpm_min) = rownames(heatmap_data)
                     names(tpm_max) = rownames(heatmap_data)
                     
                     tpm_ha <- rowAnnotation(
                       min.max = anno_simple(cbind(tpm_min, 
                                                   tpm_max), 
                                             col = tpm_col_fun,
                                             gp = gpar(col = 'black',
                                                       lwd = 0.1),
                                             border = TRUE,
                                             simple_anno_size = unit(0.2, "cm")),
                       show_annotation_name = FALSE)
                     
                     #Clade annotation
                     
                     clade_ha <- rowAnnotation(
                       'sub-family' = anno_simple(
                         clade_info,
                         col = annotation_col,
                       ),
                       annotation_name_gp = gpar(fontsize = 10)
                     )
                     
                     #Change rownames to remove PCHAS_
                     rownames(heatmap_data) = str_split_fixed(rownames(heatmap_data), 
                                                              pattern = '_', 
                                                              n = 2)[,2]
                     
                     colnames(heatmap_data) <- times_stages_table$time[match(colnames(heatmap_data),
                                                                             times_stages_table$r_stage_diff_count)]
                     
                     heatmap_data <- heatmap_data[,order(colnames(heatmap_data)),
                                                  drop = FALSE] 
                     
                     
                     h = Heatmap(heatmap_data,
                                 name = paste0('z-score'),
                                 col = c(cbPalette[6],
                                         'white', 
                                         cbPalette[7]),
                                 row_names_gp = gpar(fontsize = ifelse(
                                   nrow(heatmap_data) > 13, 
                                   12*(13/nrow(heatmap_data)), 
                                   12)
                                 ),
                                 column_names_gp = gpar(fontsize = 10),
                                 row_dend_width = unit(3, "cm"),
                                 right_annotation = tpm_ha,
                                 left_annotation = clade_ha,
                                 width = unit(4.5, 'cm'),
                                 cluster_columns = FALSE,
                                 height = unit(7,'cm'),
                                 row_title = NULL,
                                 cluster_rows = FALSE,
                                 column_title = paste(title),
                                 heatmap_legend_param = list(
                                   at = c(3,2,1,0,-1,-2,-3),
                                   labels_gp = gpar(fontsize = 10),
                                     title_gp = gpar(fontsize = 10)
                                 ),
                                 show_row_names = FALSE
                     )
                     return(h)
                   })

ht_list <- Reduce('+', heatmaps) #To add the list elements together

#Draw the legend
tpm_lgd <- Legend(
  title = "Min/Max log(TPM + 1)", 
  col_fun = tpm_col_fun,
  at = tpm_breaks, 
  labels = tpm_breaks,
  title_gp = gpar(fontsize = 7)
)

clade_lgd <- Legend(
  title = 'sub-family',
  at = names(SorL_col),
  legend_gp = gpar(fill = SorL_col)
)

png(filename = 'tl19-07_phaseogram_each-in-order_cir_clades.png',
    units = 'cm',
    height = 20,
    width = 22,
    res = 200)

  draw(ht_list, 
       row_title_side = 'left',
       column_title_side = 'bottom',
       heatmap_legend_side = 'left',
       annotation_legend_list = 
         list(tpm_lgd,
              clade_lgd),
       ht_gap = unit(.5,'cm')
       )
  
  dev.off()


```

```{r phaseograms_cir}

phase_rMT <- draw_heatmap_zscore(zscore_list = list(twentyfour_z$rMT) ,
                    gene_ordering_vector = phaseogram_row_order$rMT$zscore_order$Geneid,
                    filter_genes_vector = cir_id,
                    annotation_clade = 'SorL',
                    annotation_col = SorL_col,
                    threshold_tpm = 1,
                    use_times = TRUE,
                    use_order_vector = FALSE,
                    show_row_names = FALSE,
                    tpm_breaks = tpm_breaks)

phase_SBP <- draw_heatmap_zscore(zscore_list = list(twentyfour_z$SBP),
                    gene_ordering_vector = phaseogram_time_order$SBP$zscore_order$Geneid,
                    filter_genes_vector = cir_id,
                    annotation_clade = 'SorL',
                    annotation_col = SorL_col,
                    threshold_tpm = 1,
                    use_times = TRUE,
                    use_order_vector = FALSE,
                    show_row_names = FALSE,
                    tpm_breaks = tpm_breaks)

draw_heatmap_zscore(zscore_list = twentyfour_z,
                    gene_ordering_vector = phaseogram_row_order$SBP$zscore_order$Geneid,
                    filter_genes_vector = cir_id,
                    annotation_clade = 'clade',
                    annotation_col = clade_col,
                    threshold_tpm = 200,
                    use_times = TRUE,
                    use_order_vector = FALSE)

png(filename = 'tl19-07_phaseogram_rMTorder_cir_clades.png',
    units = 'cm',
    height = 20,
    width = 22,
    res = 200)
draw_heatmap_zscore(zscore_list = twentyfour_z,
                    gene_ordering_vector = phaseogram_time_order$rMT$zscore_order$Geneid,
                    filter_genes_vector = cir_id,
                    annotation_clade = 'clade',
                    annotation_col = clade_col,
                    threshold_tpm = 1,
                    use_times = TRUE,
                    use_order_vector = FALSE,
                    tpm_mat = FALSE)
dev.off()

png(filename = 'tl19-07_phaseogram_rMTorder_cir_SorL.png',
    units = 'cm',
    height = 20,
    width = 22,
    res = 200)
draw_heatmap_zscore(zscore_list = twentyfour_z,
                    gene_ordering_vector = phaseogram_time_order$rMT$zscore_order$Geneid,
                    filter_genes_vector = cir_id,
                    annotation_clade = 'SorL',
                    annotation_col = SorL_col,
                    threshold_tpm = 1,
                    use_times = TRUE,
                    use_order_vector = FALSE,
                    show_row_names = FALSE,
                    tpm_mat = FALSE)
dev.off()

png(filename = 'tl19-07_phaseogram_SBPorder_cir_SorL.png',
    units = 'cm',
    height = 20,
    width = 22,
    res = 200)
draw_heatmap_zscore(zscore_list = twentyfour_z,
                    gene_ordering_vector = phaseogram_time_order$SBP$zscore_order$Geneid,
                    filter_genes_vector = cir_id,
                    annotation_clade = 'SorL',
                    annotation_col = SorL_col,
                    threshold_tpm = 1,
                    use_times = TRUE,
                    use_order_vector = FALSE,
                    show_row_names = FALSE,
                    tpm_breaks = tpm_breaks,
                    tpm_mat = FALSE)
dev.off()

```

## Phaseograms by clade.

```{r phaseograms_by_clade}
cir_clades <- unique(cir_clade_info$clade) %>% sort
lapply(cir_clades, 
       function(cir_clade_name){
         cirs_in_clade <- cir_clade_info$Geneid[cir_clade_info$clade %in% cir_clade_name]
         if(length(cirs_in_clade) > 1){
           draw_heatmap_zscore(zscore_list = twentyfour_z,
                               gene_ordering_vector = phaseogram_row_order$rMT$zscore_order$Geneid,
                               filter_genes_vector = cirs_in_clade,
                               extra_title = paste0('_', cir_clade_name),
                               annotation_clade = TRUE)
           if(global_save_var){
             png(filename = paste0('tl19-07_phaseogram_rMTorder_cir_', 
                                   cir_clade_name,
                                   '.png'),
                 units = 'cm',
                 height = 20,
                 width = 22,
                 res = 200)
             draw_heatmap_zscore(zscore_list = twentyfour_z,
                                 gene_ordering_vector = phaseogram_row_order$rMT$zscore_order$Geneid,
                                 filter_genes_vector = cirs_in_clade,
                                 extra_title = paste0('_', cir_clade_name))
             dev.off()
           }
           
         }
       })
```


Putting them side by side you can see the delay with the whole transcriptome - genes upregulated in certain rMT stages appear to be upregulated in both the same stage and the next stage 3h later.


# Heatmap of all of the expressed pir genes in each stage, ordered by each transmission type. - Figure 3b

```{r highest_expressed_stage_heatmap_fig3b}

# Get order of pir genes by highest expressed genes in each sample.

combined_data_pir_ht_list <- lapply(names(twentyfour_avgtpm_noschz), 
       function(list_name){
         
         combined_data_pir <- getElement(twentyfour_avgtpm_noschz, 
                                     list_name)$tpm %>% 
           filter(Geneid %in% cir_id) %>% 
           column_to_rownames(var = 'Geneid')
         
         #Ordering that a more understandable order
         
         combined_data_pir <- combined_data_pir[,c(ordering(colnames(combined_data_pir)[-1], 
                                                            order_vector)),
                                                drop = FALSE]
         
         # combined_data_ordered <- melt(
         #   (
         #     combined_data_pir %>% 
         #       rownames_to_column(var = 'Geneid')
         #   ),
         #   id = 'Geneid',
         #   variable.name = 'stage',
         #   value.name = 'tpm') %>% 
         #   group_by(Geneid) %>% 
         #   top_n(tpm, 
         #         n = 1) %>% 
         #   arrange(stage,
         #           desc(tpm)) %>%
         #   distinct(Geneid, 
         #            .keep_all = TRUE) %>%  #Keep only the ones that are uniquely highest expressed in one sample
         #   filter(tpm > 0)
           
         combined_data_ordered <- tibble(Geneid = names(apply(combined_data_pir, 1, mean)),
                                         means = apply(combined_data_pir, 1, mean),
                                         subfam = cir_clade_info$SorL[match(names(apply(combined_data_pir, 1, mean)), 
                                                                            cir_clade_info$Geneid)]) %>% 
           filter(means > 1) %>% 
           arrange(subfam, desc(means)) %>% 
           .$Geneid
         
         combined_data_pir_ht <- combined_data_pir[
           order(
             match(rownames(combined_data_pir), 
                   combined_data_ordered),
             na.last = NA #Remove NAs
           ),
         ]
         
         return(
           list(order = combined_data_pir_ht)
         )
       })
names(combined_data_pir_ht_list) <- names(twentyfour_avgtpm_noschz)

lapply(names(combined_data_pir_ht_list),
       function(list_name_to_order){
         
         combined_data_pir_ht <- getElement(combined_data_pir_ht_list,
                                            list_name_to_order)$order
         
         pir_highest_tpm_order <- rownames(combined_data_pir_ht)
         
         maxcol <- ceiling(
           max(log1p(combined_data_pir_ht)
           )
         )
         
         #Sub-family annotation
         clade_info <- getElement(cir_clade_info,
                                  'SorL')[match(pir_highest_tpm_order, 
                                                cir_clade_info$Geneid)]
         annotation_col <- SorL_col
         
         #Subfamily annotation
         
         clade_ha <- rowAnnotation(
           'sub-family' = anno_simple(
             clade_info,
             col = annotation_col,
           ),
           annotation_name_gp = gpar(fontsize = 10)
         )
         
         anc_ha <- rowAnnotation(foo = anno_mark(at = 1, 
                                                 labels = 'ancestral',
                                                 labels_gp = gpar(fontsize = 7),
                                                 link_width = unit(3, "mm")))
         
         #lapply across the datasets now, for each order
         ht_list <- lapply(names(combined_data_pir_ht_list),
                           function(list_name){
                             
                             combined_data_pir_ht <- getElement(twentyfour_avgtpm_noschz, 
                                                                list_name)$tpm %>% 
                               column_to_rownames(var = 'Geneid')
                             
                             #Get the times instead of the stage names.
                             colnames(combined_data_pir_ht) <- times_stages_table$time[match(colnames(combined_data_pir_ht),
                                                                                             
                                                                                             times_stages_table$r_stage_diff_count)]
                             
                             combined_data_pir_ht <- combined_data_pir_ht[,order(colnames(combined_data_pir_ht)),
                                                                          drop = FALSE] 
                             
                             
                             Heatmap(
                               log1p(combined_data_pir_ht)[pir_highest_tpm_order,],
                               cluster_rows = FALSE,
                               cluster_columns = FALSE,
                               show_row_names = FALSE,
                               name = 'log(TPM+1)', 
                               col = colorRamp2(c(0, 
                                                  maxcol/4, 
                                                  maxcol/2, 
                                                  3*maxcol/4, 
                                                  maxcol), 
                                                viridis(5)),
                               na_col = 'white', 
                               border = TRUE,
                               border_gp = gpar(lwd = 0.1),
                               column_names_gp = gpar(fontsize = 10),
                               row_dend_width = unit(3, "cm"),
                               width = unit(4.5, 'cm'),
                               height = unit(7,'cm'),
                               row_title = NULL,
                               left_annotation = if(
                                 list_name %in% first(names(combined_data_pir_ht_list))
                               ){
                                 clade_ha
                               }else{
                                 NULL
                               },
                               right_annotation = if(
                                 list_name %in% last(names(combined_data_pir_ht_list))
                               ){
                                 anc_ha
                               }else{
                                 NULL
                               },
                               # row_split =  cir_clade_info$SorL[match(pir_highest_tpm_order, 
                               #                                        cir_clade_info$Geneid)],
                               column_title = paste(list_name),
                               heatmap_legend_param = list(
                                 labels_gp = gpar(fontsize = 10),
                                 title_gp = gpar(fontsize = 10,
                                                 fontface = 'bold')
                               )
                             )
                           }
         )
         ht_list <- Reduce(`+`, ht_list)
         clade_lgd <- Legend(
           title = 'sub-family',
           at = names(SorL_col),
           legend_gp = gpar(fill = SorL_col)
         )
         
         png(filename = paste0('tl19-07_combined_pirs_ordered_highest_stage_expression_heatmap_TPM_',
                               list_name_to_order, 'order',
                               '.png'),
             width = 20,
             height = 10,
             units = 'cm',
             res = 330)
         
         draw(ht_list, 
              row_title_side = 'left',
              column_title_side = 'bottom',
              heatmap_legend_side = 'right',
              annotation_legend_side = 'right',
              annotation_legend_list = list(clade_lgd),
              ht_gap = unit(.35,'cm'),
              merge_legend = TRUE
         )
         
         dev.off()
       })

```

```{r highest_genes_stage}
highest_pirs_stage_transmission <- lapply(names(twentyfour_avgtpm_noschz), 
       function(list_name){
         
         combined_data_pir <- getElement(twentyfour_avgtpm_noschz, 
                                     list_name)$tpm %>% 
           filter(Geneid %in% cir_id) %>% 
           column_to_rownames(var = 'Geneid')
         
         #Ordering that a more understandable order
         
         combined_data_pir <- combined_data_pir[,c(ordering(colnames(combined_data_pir)[-1], 
                                                            order_vector)),
                                                drop = FALSE]
         
         combined_data_ordered <- melt(
           (
             combined_data_pir %>%
               rownames_to_column(var = 'Geneid')
           ),
           id = 'Geneid',
           variable.name = 'stage',
           value.name = 'tpm') %>%
           group_by(Geneid) %>%
           top_n(tpm,
                 n = 1) %>%
           arrange(stage,
                   desc(tpm)) %>%
           distinct(Geneid,
                    .keep_all = TRUE) %>%  #Keep only the ones that are uniquely highest expressed in one sample
           filter(tpm > 0)

         
         highest_pir_stage_list <- lapply(unique(combined_data_ordered$stage), 
                                          function(stage_name){
                                            filter(combined_data_ordered, 
                                                   stage %in% stage_name)$Geneid
                                          }
         )
         names(highest_pir_stage_list) <- unique(combined_data_ordered$stage)
         return(highest_pir_stage_list)
       })
names(highest_pirs_stage_transmission) <- names(twentyfour_avgtpm_noschz)
```

```{r different_highest_genes_between_transmission}
stage_names <- ordering(colnames(twentyfour_avgtpm_noschz$rMT$tpm)[-1],
                        order_vector)
agree_highest_pirs <- lapply(stage_names, 
       function(stage_name){
  agree(
    lapply(highest_pirs_stage_transmission, 
           getElement, 
           stage_name)
  )
})
names(agree_highest_pirs) <- stage_names

disagree_highest_pirs_rMThigher <- lapply(stage_names, 
       function(stage_name){
  disagree(
    lapply(highest_pirs_stage_transmission, 
           getElement, 
           stage_name)
  )
})
names(disagree_highest_pirs_rMThigher) <- stage_names

disagree_highest_pirs_SBPhigher <- lapply(stage_names, 
       function(stage_name){
  disagree(
    lapply(rev(highest_pirs_stage_transmission), 
           getElement, 
           stage_name)
  )
})
names(disagree_highest_pirs_SBPhigher) <- stage_names
```

# pir expression by clade/sub-family

```{r highest_genes_clade, results = "asis"}
lapply(names(highest_pirs_stage_transmission), 
       function(transmission_name){
         transmission_highest_pirs <- getElement(highest_pirs_stage_transmission,
                                                 transmission_name)
         lapply(names(transmission_highest_pirs), 
                function(top_pirs_name){
                  top_pirs <- getElement(transmission_highest_pirs, 
                                         top_pirs_name)
                  mutate(cir_clade_info, 
                         in_top = str_detect(Geneid, 
                                             pattern = paste(top_pirs, collapse = '|')) ) %>% 
                    group_by(clade) %>% 
                    dplyr::summarise(num = sum(in_top),
                                     prop_of_stage_top_pirs = round(sum(in_top)/length(top_pirs),
                                                                    digits = 3)*100,
                                     prop_of_clade = round(sum(in_top)/length(Geneid),
                                                           digits = 3)*100) %>% 
                    kable(format = 'html', 
                          caption = paste0(transmission_name, 
                                           '_', 
                                           top_pirs_name), 
                          escape = FALSE) %>% 
                    kable_styling()
                })
       })
```

Unknowns always highest in the ring stages.


## Proportion table of S/L clade expression by stage.

```{r proportion_data}

tpm_data_twentyfour <- twentyfour_ct_comb$tpm %>% 
  filter(Geneid %in% cir_id) %>% 
  melt(id.vars = 'Geneid', 
       variable.name = 'sample', 
       value.name = 'tpm') %>% 
  mutate(stage = str_extract(sample, 
                             pattern = '(?<=\\w{3}_\\w{3}_).+(?=_[[:digit:]]$)|sch.culture')) %>%
  mutate(transmission = str_extract(sample, pattern = 'rMT|SBP')) %>% 
  filter(stage != 'sch.culture') %>% 
  mutate(clade = cir_clade_info$clade[match(Geneid, 
                                            cir_clade_info$Geneid)],
         chrom = str_extract(Geneid, 
                             pattern = '(?<=PCHAS_)[[:digit:]]{2}')
         ) %>% 
  mutate(
    SorL = str_extract(clade, 
                       pattern = '(L|S(?=[[:digit:]]))|ancestral|unk|pir-like'),
    # stage =  factor(stage, 
    #                 levels = ordering(stage, order_vector))
  ) %>% 
  group_by(transmission,
           stage, 
           Geneid,
           clade,
           chrom,
           SorL) %>% 
  dplyr::summarise(tpm = mean(tpm))

```


```{r clade_proportion}
tpm_data_twentyfour %>% 
    group_by(transmission,
           stage, 
           clade) %>% 
  dplyr::summarise(max_gene = max(tpm),
                   total_clade = sum(tpm)) %>%
  group_by(stage) %>% 
  dplyr::mutate(total_stage = sum(total_clade)) %>% 
  dplyr::mutate(
    prop = round(total_clade/total_stage, digits = 2),
    prop_from_max_gene = ifelse(total_clade > 0,
                                round(max_gene/total_clade, digits = 2),
                                0)
  ) %>% 
  # Prop from max gene to show how much of the clade expression is from the highest expressed gene of the clade.
  filter(prop > 0.0001) %>%
  dplyr::arrange(transmission, desc(prop)) %>% 
  select(-max_gene) %>% 
  kable(format = 'html', 
        caption = 'Proportion of pir clade expression for each stage', 
        escape = FALSE) %>% 
  kable_styling() %>% 
  scroll_box(width = "100%", height = "500px")

```

## Stacked bar chart of clade expression.

```{r clades_barchart}
tpm_data_clade <- twentyfour_ct_comb$tpm %>% 
  filter(Geneid %in% cir_id) %>% 
  melt(id.vars = 'Geneid', 
       variable.name = 'sample', 
       value.name = 'tpm') %>% 
  mutate(stage = str_extract(sample, 
                             pattern = '(?<=\\w{3}_\\w{3}_).+(?=_[[:digit:]]$)|sch.culture')) %>%
  mutate(stage = times_stages_table$time[match(stage, times_stages_table$r_stage_diff_count)]) %>% 
  mutate(transmission = str_extract(sample, pattern = 'rMT|SBP')) %>% 
  filter(stage != 'sch.culture') %>% 
  mutate(clade = cir_clade_info$clade[match(Geneid, 
                                            cir_clade_info$Geneid)]) %>% 
  # mutate(stage =  factor(stage, 
  #                        levels = ordering(stage, 
  #                                          order_vector))) %>% 
  group_by(transmission,
           stage, 
           clade) %>% 
  dplyr::summarise(total_tpm = sum(tpm)) %>% 
  arrange(stage)

y <- ggplot(data = tpm_data_clade, 
              aes(
                x = transmission,
                y = total_tpm, 
                fill = clade,
                group = transmission
              )) +
    geom_bar(position = position_stack(),
             stat = 'identity',
             colour = 'black',
             size = 0.1) +
    scale_fill_manual(
      breaks = unique(tpm_data_clade$clade),
      values = setNames(
        c(cbPalette, 
          'red', 
          'white')[1:length(unique(tpm_data_clade$clade))],
        unique(tpm_data_clade$clade)
      )
    ) +
    scale_color_manual('black') + 
    # labs(fill = stack_label) +
    # scale_y_continuous(breaks = max_tpm) +
    theme_classic() +
    scale_size(range = c(0,3)) +
    ylab(
      bquote('total '~italic(.('pir'))~' TPM')
    ) + 
    facet_grid(.~stage, 
               scales = "free_x",
               space = "free_x") +
    theme(
      axis.title.x=element_blank(),
      # axis.text.x=element_blank(),
      axis.text.y = element_text(size = 5),
      axis.title.y = element_text(size = 8),
      legend.title = element_text(size = 7),
      legend.text = element_text(size = 5),
      legend.key.size = unit(3,'mm'),
      legend.key.width = unit(2,'mm'),
      strip.text.x = element_text(size=7, 
                                  face = 'bold', 
                                  angle = 0),
      strip.background = element_rect(
        color="black", 
        size=0.1, 
        linetype="solid"
      )
    ) 
y

ggsave2('tl20-05_subclades_totalTPM_barchart.pdf',
        plot = y,
        dpi = 300,
        width = 15,
        height = 10,
        units = 'cm')
  
```

## Clades proportion bar chart

```{r clades_prop_barchart}
y <- ggplot(data = tpm_data_clade, 
              aes(
                x = stage,
                y = total_tpm, 
                fill = clade,
                group = transmission
              )) +
    geom_bar(position = 'fill',
             stat = 'identity',
             colour = 'black',
             size = 0.1) +
    scale_fill_manual(
      breaks = sort(unique(tpm_data_clade$clade)),
      values = clade_col,
      guide = guide_legend(reverse = TRUE) 
    ) +
    scale_color_manual('black') + 
    # labs(fill = stack_label) +
    # scale_y_continuous(breaks = max_tpm) +
    theme_classic() +
    scale_size(range = c(0,3)) +
    ylab(
      bquote('proportion of total '~italic(.('pir'))~' TPM')
    ) + 
    facet_grid(.~transmission, 
               scales = "free_x",
               space = "free_x") +
    theme(
      axis.title.x=element_blank(),
      axis.text.x=element_text(size = 7, 
                                 angle = 90),
      axis.text.y = element_text(size = 5),
      axis.title.y = element_text(size = 8),
      legend.title = element_text(size = 7),
      legend.text = element_text(size = 5),
      legend.key.size = unit(3,'mm'),
      legend.key.width = unit(2,'mm'),
      strip.text.x = element_text(size=7, 
                                  face = 'bold', 
                                  angle = 0),
      strip.background = element_rect(
        color="black", 
        size=0.1, 
        linetype="solid"
      )
    ) 
y

ggsave2('tl20-05_subclades_propTPM_barchart.png',
        plot = y,
        dpi = 300,
        width = 15,
        height = 10,
        units = 'cm')

```


## S/L clade member proportions among the pirs expressed highest at each stage.

```{r highest_pirs_SorL, results = "asis"}
lapply(names(highest_pirs_stage_transmission), 
       function(transmission_name){
         transmission_highest_pirs <- getElement(highest_pirs_stage_transmission,
                                                 transmission_name)
         lapply(names(transmission_highest_pirs), 
                function(top_pirs_name){
                  top_pirs <- getElement(transmission_highest_pirs, 
                                         top_pirs_name)
                  mutate(cir_clade_info, 
                         clade = str_extract(clade, pattern = '(L|S(?=[[:digit:]]))|ancestral|unk|pir-like'),
                         in_top = str_detect(Geneid, 
                                             pattern = paste(top_pirs, collapse = '|')) ) %>% 
                    group_by(clade) %>% 
                    dplyr::summarise(num = sum(in_top),
                                     prop_of_stage_top_pirs = round(sum(in_top)/length(top_pirs),
                                                                    digits = 3)*100,
                                     prop_of_clade = round(sum(in_top)/length(Geneid),
                                                           digits = 3)*100) %>% 
                    kable(format = 'html', 
                          caption = paste0(transmission_name, 
                                           '_', 
                                           top_pirs_name), 
                          escape = FALSE) %>% 
                    kable_styling()
                })
       })
```

SBP Late Trophs have highest expression of more Ls than the rMT late trophs. This is probably because the expression of the pirs is generally more spread out in the rMT, does this culminate as them having more genes in different phases in the Fourier results? 

All the unknown clades are expressed in the earlier ring stages, however I don't think they themselves are expressed much at all.

## Bar chart of S and L clade expression across time.

```{r SorL_barchart}
tpm_data_SorL <- twentyfour_ct_comb$tpm %>% 
  filter(Geneid %in% cir_id) %>% 
  melt(id.vars = 'Geneid', 
       variable.name = 'sample', 
       value.name = 'tpm') %>% 
  mutate(stage = str_extract(sample, 
                             pattern = '(?<=\\w{3}_\\w{3}_).+(?=_[[:digit:]]$)|sch.culture')) %>%
    mutate(stage = times_stages_table$time[match(stage, times_stages_table$r_stage_diff_count)]) %>% 
  mutate(transmission = str_extract(sample, pattern = 'rMT|SBP')) %>% 
  filter(stage != 'sch.culture') %>% 
  mutate(clade = cir_clade_info$clade[match(Geneid, 
                                            cir_clade_info$Geneid)]) %>% 
  mutate(SorL = str_extract(clade, 
                            pattern = '(L|S(?=[[:digit:]]))|ancestral|unk|pir-like'),
         # stage =  factor(stage, levels = ordering(stage, order_vector))
         ) %>% 
  group_by(transmission,
           stage, 
           SorL) %>% 
  dplyr::summarise(total_tpm = sum(tpm))

y <- ggplot(data = tpm_data_SorL, 
              aes(
                x = transmission,
                y = total_tpm, 
                fill = SorL,
                group = transmission
              )) +
    geom_bar(position = position_stack(),
             stat = 'identity',
             colour = 'black',
             size = 0.1) +
    scale_fill_manual(
      values = SorL_col,
      guide = guide_legend(reverse = TRUE)
    ) +
    scale_color_manual('black') + 
    # labs(fill = stack_label) +
    # scale_y_continuous(breaks = max_tpm) +
    theme_classic() +
    scale_size(range = c(0,3)) +
    ylab(
      bquote('total '~italic(.('pir'))~' TPM')
    ) + 
    facet_grid(.~stage, 
               scales = "free_x",
               space = "free_x") +
    theme(
      axis.title.x=element_blank(),
      # axis.text.x=element_blank(),
      axis.text.y = element_text(size = 5),
      axis.title.y = element_text(size = 8),
      legend.title = element_text(size = 7),
      legend.text = element_text(size = 5),
      legend.key.size = unit(3,'mm'),
      legend.key.width = unit(2,'mm'),
      strip.text.x = element_text(size=7, 
                                  face = 'bold', 
                                  angle = 0),
      strip.background = element_rect(
        color="black", 
        size=0.1, 
        linetype="solid"
      )
    ) 
y

ggsave2('tl20-05_clades_totalTPM_barchart.pdf',
        plot = y,
        dpi = 300,
        width = 15,
        height = 10,
        units = 'cm')
  
```

```{r SorL_barchart_transmission-facet}
tpm_data_SorL <- twentyfour_ct_comb$tpm %>% 
  filter(Geneid %in% cir_id) %>% 
  melt(id.vars = 'Geneid', 
       variable.name = 'sample', 
       value.name = 'tpm') %>% 
  mutate(stage = str_extract(sample, 
                             pattern = '(?<=\\w{3}_\\w{3}_).+(?=_[[:digit:]]$)|sch.culture')) %>%
    mutate(stage = times_stages_table$time[match(stage, times_stages_table$r_stage_diff_count)]) %>% 
  mutate(transmission = str_extract(sample, pattern = 'rMT|SBP')) %>% 
  filter(stage != 'sch.culture') %>% 
  mutate(clade = cir_clade_info$clade[match(Geneid, 
                                            cir_clade_info$Geneid)]) %>% 
  mutate(SorL = str_extract(clade, 
                            pattern = '(L|S(?=[[:digit:]]))|ancestral|unk|pir-like'),
         # stage =  factor(stage, levels = ordering(stage, order_vector))
         ) %>% 
  group_by(transmission,
           stage, 
           SorL) %>% 
  dplyr::summarise(total_tpm = sum(tpm)) %>% 
  mutate(SorL = factor(SorL, 
                       levels = sort(unique(SorL))))

y <- ggplot(data = tpm_data_SorL, 
              aes(
                x = stage,
                y = total_tpm, 
                fill = SorL,
                # group = transmission
              )) +
  geom_bar(position = position_stack(),
           stat = 'identity',
           colour = 'black',
           size = 0.1) +
  scale_fill_manual(
    values = SorL_col,
    guide = guide_legend(reverse = FALSE)
  ) +
  scale_color_manual('black') + 
  # labs(fill = stack_label) +
  # scale_y_continuous(breaks = max_tpm) +
  theme_classic() +
  scale_size(range = c(0,3)) +
  ylab(
    bquote('total '~italic(.('pir'))~' TPM')
  ) + 
  facet_grid(.~transmission, 
             scales = "free_x",
             space = "free_x") +
  labs(fill = 'sub-family') +
    theme(
      axis.title.x=element_blank(),
      # axis.text.x=element_blank(),
      axis.text.y = element_text(size = 5),
      axis.title.y = element_text(size = 8),
      legend.title = element_text(size = 7),
      legend.text = element_text(size = 5),
      legend.key.size = unit(3,'mm'),
      legend.key.width = unit(2,'mm'),
      strip.text.x = element_text(size=7, 
                                  face = 'bold', 
                                  angle = 0),
      strip.background = element_rect(
        color="black", 
        size=0.1, 
        linetype="solid"
      )
    ) 
y

ggsave2('tl20-05_SorL_totalTPM_facet-transmission_barchart.pdf',
        plot = y,
        dpi = 300,
        width = 15,
        height = 10,
        units = 'cm')
  
```

## S or L proportion of expression bar chart

```{r add_berghei_SorL_prop}
#Add berghei data
# berghei_SorL_file <- list.files('..', 
#                                 recursive = TRUE, 
#                                 pattern = 'tl20-05_SorL-subfamily_pir.csv', 
#                                 full.names = TRUE)
berghei_SorL <- read_csv('../tl20-05_bergheisystematicanalysis_nextflowoutput/tl20-05_SorL-subfamily_pir.csv') %>% 
  filter(stage %in% c('Asexual.SchizontA',
                      'Asexual.SchizontB',
                      'Asexual.Ring',
                      'Asexual.Trophozoite',
                      'Asexual.Mixed')) 
berghei_SorL_avg <- berghei_SorL %>% 
  group_by(stage,
           SorL) %>% 
  dplyr::summarise(total_tpm = sum(total_tpm)) %>% 
  mutate(SorL = str_extract(SorL,
                            pattern = 'S|L|ancestral'),
         transmission = 'berghei')

```


```{r}
y <- ggplot(data = rbind(
  tpm_data_SorL,
  berghei_SorL_avg
), 
aes(
  x = stage,
                y = total_tpm, 
                fill = SorL,
                # group = transmission
              )) +
  geom_bar(position = 'fill',
           stat = 'identity',
           colour = 'black',
           size = 0.1) +
  scale_fill_manual(
    values = SorL_col,
    guide = guide_legend(reverse = FALSE)
  ) +
  scale_color_manual('black') + 
  # labs(fill = stack_label) +
  # scale_y_continuous(breaks = max_tpm) +
  theme_classic() +
  scale_size(range = c(0,3)) +
  ylab(
    bquote('proportion of total '~italic(.('pir'))~' TPM')
  ) + 
  facet_grid(.~transmission, 
             scales = "free_x",
             space = "free_x") +
  labs(fill = 'sub-family') +
    theme(
      axis.title.x=element_blank(),
      axis.text.x=element_text(angle = 90),
      axis.text.y = element_text(size = 5),
      axis.title.y = element_text(size = 8),
      legend.title = element_text(size = 7),
      legend.text = element_text(size = 5),
      legend.key.size = unit(3,'mm'),
      legend.key.width = unit(2,'mm'),
      strip.text.x = element_text(size=7, 
                                  face = 'bold', 
                                  angle = 0),
      strip.background = element_rect(
        color="black", 
        size=0.1, 
        linetype="solid"
      )
    ) 
y

ggsave2('tl20-05_SorL_totalTPM_facet-transmission_prop_barchart.pdf',
        plot = y,
        dpi = 300,
        width = 15,
        height = 10,
        units = 'cm')
```


## S or L proportion of expression.

```{r SorL_proportion_table}
tpm_data_twentyfour %>% 
    group_by(transmission,
           stage, 
           SorL) %>% 
  dplyr::summarise(max_gene = max(tpm),
                   total_clade = sum(tpm)) %>%
  group_by(stage) %>% 
  dplyr::mutate(total_stage = sum(total_clade)) %>% 
  dplyr::mutate(
    prop = round(total_clade/total_stage, digits = 2),
    prop_from_max_gene = ifelse(total_clade > 0,
                                round(max_gene/total_clade, digits = 2),
                                0)
  ) %>% 
  # Prop from max gene to show how much of the clade expression is from the highest expressed gene of the clade.
  filter(prop > 0.0001) %>%
  dplyr::arrange(transmission, stage, desc(prop)) %>% 
  select(-max_gene) %>% 
  kable(format = 'html', 
        caption = 'Proportion of pir clade expression for each stage', 
        escape = FALSE) %>% 
  kable_styling() %>% 
  scroll_box(width = "100%", height = "500px")

```

# Expression by chromosome

```{r chrom_proportion}
tpm_data_twentyfour %>% 
      group_by(transmission,
           stage, 
           chrom) %>% 
  dplyr::summarise(max_gene = max(tpm),
                   total_chrom = sum(tpm)) %>%
  group_by(stage) %>% 
  dplyr::mutate(total_stage = sum(total_chrom)) %>% 
  dplyr::mutate(
    prop = round(total_chrom/total_stage, digits = 2),
    prop_from_max_gene = ifelse(total_chrom > 0,
                                round(max_gene/total_chrom, digits = 2),
                                0)
  ) %>% 
  # Prop from max gene to show how much of the chrom expression is from the highest expressed gene of the chrom.
  filter(prop > 0.0001) %>%
  dplyr::arrange(transmission, desc(prop)) %>% 
  select(-max_gene) %>% 
  kable(format = 'html', 
        caption = 'Proportion of pir chrom expression for each stage', 
        escape = FALSE) %>% 
  kable_styling() %>% 
  scroll_box(width = "100%", height = "500px")
```

```{r chrom_total_bar_chart}
tpm_data_chrom <- tpm_data_twentyfour %>% 
  mutate(stage = times_stages_table$time[match(stage, 
                                               times_stages_table$r_stage_diff_count)]) %>% 
  group_by(transmission,
           stage, 
           chrom) %>% 
  dplyr::summarise(total_tpm = sum(tpm))

y <- ggplot(data = tpm_data_chrom, 
              aes(
                x = transmission,
                y = total_tpm, 
                fill = chrom,
                group = transmission
              )) +
    geom_bar(position = position_stack(),
             stat = 'identity',
             colour = 'black',
             size = 0.1) +
  scale_fill_manual(
    breaks = unique(tpm_data_chrom$chrom),
    values = setNames(
      c(
        plasma(length(unique(tpm_data_chrom$chrom)))[c(TRUE, NA)]
      ),
      unique(tpm_data_chrom$chrom)
    ),
    guide = guide_legend(reverse = TRUE)
  ) +
  scale_color_manual('black') + 
  # labs(fill = stack_label) +
  # scale_y_continuous(breaks = max_tpm) +
  theme_classic() +
  scale_size(range = c(0,3)) +
  ylab(
    bquote('total '~italic(.('pir'))~' TPM')
  ) + 
  facet_grid(.~stage, 
             scales = "free_x",
               space = "free_x") +
    theme(
      axis.title.x=element_blank(),
      # axis.text.x=element_blank(),
      axis.text.y = element_text(size = 5),
      axis.title.y = element_text(size = 8),
      legend.title = element_text(size = 7),
      legend.text = element_text(size = 5),
      legend.key.size = unit(3,'mm'),
      legend.key.width = unit(2,'mm'),
      strip.text.x = element_text(size=7, 
                                  face = 'bold', 
                                  angle = 0),
      strip.background = element_rect(
        color="black", 
        size=0.1, 
        linetype="solid"
      )
    ) 
y

# ggsave2('tl20-05_chroms_TPM_barchart.pdf',
#         plot = y,
#         dpi = 300,
#         width = 15,
#         height = 10,
#         units = 'cm')
#   
```

```{r chrom_prop_bar_chart}

y <- ggplot(data = tpm_data_chrom) +
  geom_bar_pattern(
    aes(
      x = stage,
      y = total_tpm, 
      fill = chrom,
      group = transmission,
      pattern = chrom
    ),
    position = 'fill',
    stat = 'identity',
    colour = 'black',
    size = 0.1,
    pattern_density = 0.05,
    pattern_spacing = 0.02,
    pattern_key_scale_factor = 0.5
  ) +
  scale_pattern_manual(
    values = rep(c('none', 
                   'circle'), 
                 each = length(c(cbPalette, 
                                 'red', 
                                 'white')), 
                 length.out = length(unique(tpm_data_chrom$chrom))),
    labels = unique(tpm_data_chrom$chrom),
    guide = guide_legend(reverse = TRUE),
    name = 'chromosome'
  ) +
  scale_fill_manual(
    breaks = unique(tpm_data_chrom$chrom),
    values = rep_len(c(cbPalette, 
                       'red', 
                       'white'),
                     length.out = length(unique(tpm_data_chrom$chrom))),
    labels =  unique(tpm_data_chrom$chrom),
    guide = guide_legend(reverse = TRUE),
    name = 'chromosome'
  ) +
  scale_color_manual('black') + 
  # labs(fill = stack_label) +
  # scale_y_continuous(breaks = max_tpm) +
  theme_classic() +
    scale_size(range = c(0,3)) +
    ylab(
      bquote('total '~italic(.('pir'))~' TPM')
    ) + 
    facet_grid(.~transmission, 
               scales = "free_x",
               space = "free_x") +
    theme(
      axis.title.x=element_blank(),
      axis.text.x=element_text(size = 10, 
                                 angle = 0),
      axis.text.y = element_text(size = 5),
      axis.title.y = element_text(size = 8),
      legend.title = element_text(size = 7),
      legend.text = element_text(size = 5),
      legend.key.size = unit(3,'mm'),
      legend.key.width = unit(2,'mm'),
      strip.text.x = element_text(size=10, 
                                  face = 'bold', 
                                  angle = 0),
      strip.background = element_rect(
        color="black", 
        size=0.1, 
        linetype="solid"
      )
    ) 
y

ggsave2('tl20-05_chroms_propTPM_barchart.png',
        plot = y,
        dpi = 300,
        width = 15,
        height = 10,
        units = 'cm')

```

Clearly a massive upregulation of chr6 in rMT.

```{r chrom_6_L4s}
cir_clade_info %>% 
  mutate(
    chrom = str_extract(Geneid, 
                        '(?<=PCHAS_)[[:digit:]]{2}')
  ) %>% 
  dplyr::group_by(clade, 
                  chrom) %>% 
  dplyr::summarise(num = n()) %>% 
  dplyr::mutate(freq = num/sum(num)*100) %>% 
  arrange(clade,
          desc(freq))

cir_clade_info %>% 
  mutate(
    chrom = str_extract(Geneid, 
                        '(?<=PCHAS_)[[:digit:]]{2}')
  ) %>% 
  dplyr::group_by(chrom, 
                  clade) %>% 
  dplyr::summarise(num = n()) %>% 
  dplyr::mutate(freq = num/sum(num)*100) %>% 
  arrange(chrom,
          desc(freq))
```

L4 _pir_\s mostly on chr3 and chr6 (20.6% of the L4s each). 17% of L1s are on chr6.

L1 pirs make up 58.3% of chr6, and L4 pirs make up another 29.2%, only three other pirs are left, one unknown and two S7s.

## Bar chart of chromosome expression

```{r chrom_expression_bar_charts}
lapply(
    unique(tpm_data_twentyfour$chrom), 
  function(chrom_cirs){
    
         tpm_df <- filter(tpm_data_twentyfour,
                          chrom %in% chrom_cirs)
         
         #Get the order
         
         tpm_df <- mutate(tpm_df, 
                          stage = factor(stage,
                                         levels = ordering(stage,
                                                           order_vector)))
         
         maximum_tpm_value <- group_by(tpm_df, 
                                       stage, 
                                       transmission) %>% 
           dplyr::summarise(sum_tpm = sum(tpm)) %>% 
           .$sum_tpm %>% 
           max
         
         max_tpm <- as.integer(
           mround(
             seq(0, 
                 maximum_tpm_value, 
                 length.out = 5),
             base = 5
           )
         )
         
         y <- ggplot(data = tpm_df, 
                     aes(
                       x = transmission,
                       y = tpm, 
                       fill = Geneid
                     )) +
           geom_bar(position = position_stack(),
                    stat = 'identity',
                    colour = 'black',
                    size = 0.1) +
           scale_fill_manual(
             breaks = unique(tpm_df$Geneid),
             values = setNames(
               rep_len(
                 'white', 
                 length.out = length(unique(tpm_df$Geneid))
               ),
               unique(tpm_df$Geneid)
             )
           )+
           scale_color_manual('black') + 
           # labs(fill = stack_label) +
           scale_y_continuous(breaks = max_tpm) +
           theme_classic() +
           scale_size(range = c(0,3)) +
           ylab(
             bquote('total chr'~italic(.(chrom_cirs))~italic(.('pir'))~' TPM')
           ) + 
           facet_grid(.~stage, 
                      scales = "free_x",
                      space = "free_x") +
           theme(
             axis.title.x=element_blank(),
             axis.text.x=element_text(size = 8),
             axis.text.y = element_text(size = 5),
             axis.title.y = element_text(size = 8),
             legend.title = element_text(size = 7),
             legend.text = element_text(size = 5),
             legend.key.size = unit(3,'mm'),
             legend.key.width = unit(2,'mm'),
             strip.text.x = element_text(size=4, 
                                         face = 'bold', 
                                         angle = 90),
             strip.background = element_rect(
               color="black", 
               size=0.1, 
               linetype="solid"
             )
           )
         if(global_save_var){
             ggsave2(paste0('tl19-07_chr',
                            gsub(chrom_cirs, 
                                 pattern  = ' ', 
                                 replacement = '_'),
                            '_totalTPM_barchart.pdf'),
                     plot = y,
                     dpi = 300,
                     width = 15,
                     height = 10,
                     units = 'cm')
         }
         y
       })
```

# Expression by locus

```{r defining_loci}
cir_loci <- data.frame(
  Geneid = cir_id,
  chrom = str_extract(cir_id, 
                      pattern = '(?<=_)[[:digit:]]{2}'),
  number = as.numeric(
    str_extract(cir_id, 
                pattern = '(?<=_[[:digit:]]{2})[[:digit:]]+')
  )
) %>% 
  filter(!chrom %in% '00') %>% 
  #Remove chrom00 (contigs)
  group_by(chrom) %>% 
  mutate(jump = ifelse(lag(number, 
                           default = 1001) < 3000 & number - lag(number, 
                                                                 default = 0) > 1000,
                       1,
                       0)) %>% 
  mutate(
    jump = ifelse(cumsum(jump) == 1 | jump == 1, 1, 0)
  ) %>% 
  mutate(
    locus = paste0(
      chrom,
      ifelse(jump == 0 & number < 3000, 
             'Left',
             'Right')
    )
  )

# Detect 'jumps' of the gene number over 1000 within each chromosome, setting the lag default as 1001 in the
#   first part of the ifelse statement so that chroms don't have an erroneous jump if they start at high numbers
#   >1000
# Later cumsum is do that every gene after the 'jump' is included allowing us to define telomere ends.

cir_loci_list <- lapply(
  unique(cir_loci$locus),
  function(locus_name){
    cir_loci$Geneid[cir_loci$locus == locus_name]
  })

names(cir_loci_list) <- unique(cir_loci$locus)
```

```{r loci_numbers}
cir_loci %>% 
  group_by(locus) %>% 
  dplyr::summarise(num = n()) %>% 
  arrange(desc(num))
```

## Loci expression stacked bar graph

```{r loci_total_bar_chart}

tpm_data_loci <- filter(tpm_data_twentyfour,
                                       Geneid %in% cir_id) %>%
  mutate(locus = cir_loci$locus[match(Geneid, 
                                      cir_loci$Geneid)],
         stage = times_stages_table$time[match(stage, 
                                               times_stages_table$r_stage_diff_count)]) %>% 
  ungroup() %>% 
  group_by(stage, 
           transmission,
           locus) %>% 
  dplyr::summarise(max_gene = max(tpm),
                   total_tpm = sum(tpm))

y <- ggplot(data = tpm_data_loci, 
              aes(
                x = transmission,
                y = total_tpm, 
                fill = locus,
                group = transmission
              )) +
    geom_bar(position = position_stack(),
             stat = 'identity',
             colour = 'black',
             size = 0.1) +
  scale_fill_manual(
    breaks = unique(tpm_data_loci$locus),
    values = setNames(
      c(
        plasma(length(unique(tpm_data_loci$locus)))[
          ifelse(str_detect(unique(tpm_data_loci$locus),
                            pattern = 'Left'),
                 TRUE,
                 NA)
        ]
      ),
      unique(tpm_data_loci$locus)
    ),
    guide = guide_legend(reverse = TRUE)
  ) +
  scale_color_manual('black') + 
  # labs(fill = stack_label) +
  # scale_y_continuous(breaks = max_tpm) +
  theme_classic() +
  scale_size(range = c(0,3)) +
  ylab(
    bquote('total '~italic(.('pir'))~' TPM')
  ) + 
  facet_grid(.~stage, 
             scales = "free_x",
               space = "free_x") +
    theme(
      axis.title.x=element_blank(),
      # axis.text.x=element_blank(),
      axis.text.y = element_text(size = 5),
      axis.title.y = element_text(size = 8),
      legend.title = element_text(size = 7),
      legend.text = element_text(size = 5),
      legend.key.size = unit(3,'mm'),
      legend.key.width = unit(2,'mm'),
      strip.text.x = element_text(size=7, 
                                  face = 'bold', 
                                  angle = 0),
      strip.background = element_rect(
        color="black", 
        size=0.1, 
        linetype="solid"
      )
    ) 
y

# ggsave2('tl20-05_loci_TPM_barchart.pdf',
#         plot = y,
#         dpi = 300,
#         width = 15,
#         height = 10,
#         units = 'cm')
#   
```

## Expression by locus proportions

```{r locus_prop}

tpm_data_loci %>%
  group_by(stage, 
           transmission) %>% 
  dplyr::mutate(total_stage = sum(total_tpm)) %>% 
  dplyr::mutate(
    prop = round(total_tpm/total_stage, digits = 2),
    prop_from_max_gene = ifelse(total_tpm > 0,
                                round(max_gene/total_tpm, digits = 2),
                                0)
  ) %>% 
  # Prop from max gene to show how much of the locus expression is from the highest expressed gene of the locus.
  filter(prop > 0.0001) %>%
  dplyr::arrange(desc(prop)) %>% 
  select(-max_gene) %>% 
  kable(format = 'html', 
        caption = 'Proportion of pir loci expression for each stage', 
        escape = FALSE) %>% 
  kable_styling() %>% 
  scroll_box(width = "100%", height = "500px")
```

* 34% of early and mid rMT troph comes from 06Left - 27% and 33% contribution from one gene respectively. Also 28% of late rings (17% from one gene). So spread out over multiple pir genes. Actually it is a majorly expressed locus it seems in rMT. 06Left has 14 genes, the most of any locus bar 03Left (18 genes).

```{r}
y <- ggplot(data = tpm_data_loci, 
              aes(
                x = transmission,
                y = total_tpm, 
                fill = locus,
                group = transmission
              )) +
    geom_bar(position = 'fill',
             stat = 'identity',
             colour = 'black',
             size = 0.1) +
  scale_fill_manual(
    breaks = unique(tpm_data_loci$locus),
    values = setNames(
      c(
        rep(cbPalette, 
            length.out = length(unique(tpm_data_loci$locus)),
            each = 2)[
          ifelse(str_detect(unique(tpm_data_loci$locus),
                            pattern = 'Left'),
                 TRUE,
                 NA)
        ]
      ),
      unique(tpm_data_loci$locus)
    ),
    guide = guide_legend(reverse = TRUE)
  ) +
  scale_color_manual('black') + 
  # labs(fill = stack_label) +
  # scale_y_continuous(breaks = max_tpm) +
  theme_classic() +
  scale_size(range = c(0,3)) +
  ylab(
    bquote('total '~italic(.('pir'))~' TPM')
  ) + 
  facet_grid(.~stage, 
             scales = "free_x",
               space = "free_x") +
    theme(
      axis.title.x=element_blank(),
      # axis.text.x=element_blank(),
      axis.text.y = element_text(size = 5),
      axis.title.y = element_text(size = 8),
      legend.title = element_text(size = 7),
      legend.text = element_text(size = 5),
      legend.key.size = unit(3,'mm'),
      legend.key.width = unit(2,'mm'),
      strip.text.x = element_text(size=7, 
                                  face = 'bold', 
                                  angle = 0),
      strip.background = element_rect(
        color="black", 
        size=0.1, 
        linetype="solid"
      )
    ) 
y

# ggsave2('tl20-05_loci_propTPM_barchart.pdf',
#         plot = y,
#         dpi = 300,
#         width = 15,
#         height = 10,
#         units = 'cm')
#   
```


## Expression by locus over time

```{r loci_expression}

lapply(names(cir_loci_list), 
       function(loci_name){
         
         cir_loci_genes <- getElement(cir_loci_list, 
                                      loci_name)
         
         tpm_df <- filter(tpm_data_twentyfour,
                          Geneid %in% cir_loci_genes)
         
         #Get the order
         
         tpm_df <- mutate(tpm_df, 
                          stage = factor(stage,
                                         levels = ordering(stage,
                                                           order_vector)))
         
         maximum_tpm_value <- group_by(tpm_df, 
                                       stage, 
                                       transmission) %>% 
           dplyr::summarise(sum_tpm = sum(tpm)) %>% 
           .$sum_tpm %>% 
           max
         
         max_tpm <- as.integer(
           mround(
             seq(0, 
                 maximum_tpm_value, 
                 length.out = 5),
             base = 5
           )
         )
         
         y <- ggplot(data = tpm_df, 
                     aes(
                       x = transmission,
                       y = tpm, 
                       fill = Geneid
                     )) +
           geom_bar(position = position_stack(),
                    stat = 'identity',
                    colour = 'black',
                    size = 0.1) +
           scale_fill_manual(
             breaks = unique(tpm_df$Geneid),
             values = setNames(
               rep_len(
                 'white', 
                 length.out = length(unique(tpm_df$Geneid))
               ),
               unique(tpm_df$Geneid)
             )
           )+
           scale_color_manual('black') + 
           # labs(fill = stack_label) +
           scale_y_continuous(breaks = max_tpm) +
           theme_classic() +
           scale_size(range = c(0,3)) +
           ylab(
             bquote('total '~italic(.(loci_name))~italic(.('pir'))~' TPM')
           ) + 
           facet_grid(.~stage, 
                      scales = "free_x",
                      space = "free_x") +
           theme(
             axis.title.x=element_blank(),
             axis.text.x=element_text(size = 8),
             axis.text.y = element_text(size = 5),
             axis.title.y = element_text(size = 8),
             legend.title = element_text(size = 7),
             legend.text = element_text(size = 5),
             legend.key.size = unit(3,'mm'),
             legend.key.width = unit(2,'mm'),
             strip.text.x = element_text(size=4, 
                                         face = 'bold', 
                                         angle = 90),
             strip.background = element_rect(
               color="black", 
               size=0.1, 
               linetype="solid"
             )
           )
         if(global_save_var){
             ggsave2(paste0('tl19-07_',
                            gsub(loci_name, 
                                 pattern  = ' ', 
                                 replacement = '_'),
                            '_totalTPM_barchart.pdf'),
                     plot = y,
                     dpi = 300,
                     width = 15,
                     height = 10,
                     units = 'cm')
         }
         y
       })
```

* Cyclical expression generally similar between different chromosomes.
* 01Left, 05Right dominated by the ancestral and pan-rodent pirs.
* 01Right, 03Right, 07Right, 08Left, 08Right, 09Left, 10Left, 10Right, 11Left, 11Right, 12Right, 13Right, 14Left, 14Right show association with SBP expression.
* 04Right in rMT peaks in Early Trophs, and is spread across multiple cir genes.
* 10Left peaks in Early-Mid Rings mostly due to one pir PCHAS_1001351. 12Right also peaks then in SBP due to one or two pirs.
* In some loci the higher expression in rMT is massive; 03Left, 06Left, 06Right, 12Left.

# Lower expression of _pir_ genes versus the rest of the genome

```{r low_pir_expression}
set.seed(4534)

gene_expression_df <- twentyfour_ct_comb$tpm %>% 
  melt(id.vars = 'Geneid', 
       variable.name = 'sample', 
       value.name = 'tpm') %>% 
  mutate(stage = str_extract(sample, 
                             pattern = '(?<=\\w{3}_\\w{3}_).+(?=_[[:digit:]]$)|sch.culture')) %>%
  mutate(transmission = str_extract(sample, pattern = 'rMT|SBP')) %>% 
  filter(stage != 'sch.culture') %>% 
  mutate(pir_gene = ifelse(Geneid %in% cir_id,
                           'pir',
                           'non-pir')) %>% 
  group_by(stage, 
           pir_gene,
           transmission) %>% 
  slice_sample(n = length(cir_id)) %>%
  summarise(mean_tpm = mean(tpm),
            med_tpm = round(median(tpm),
                            digits = 6)) 

gene_expression_df %>% 
  group_by(transmission, 
           pir_gene) %>% 
  slice_min(mean_tpm, n =1)

gene_expression_df %>% 
  group_by(transmission, 
           pir_gene) %>% 
  slice_max(mean_tpm, n =1)

y <- ggplot(gene_expression_df,
       aes(x = pir_gene,
           y = log1p(mean_tpm))) +
  facet_grid(~transmission) +
  ggtitle(expression(paste(italic('P. chabaudi'), ' 24h cycle'))) +
  xlab('Gene group')+
  ylab('log(Median TPM + 1)')+
  # geom_violin()+
  geom_dotplot(binaxis = 'y',
               stackdir = 'center',
               # binwidth = 1,
               # dotsize = 2,
               method = 'dotdensity') +
  geom_path(aes(group = stage,
                col = stage)) +
  theme_classic()
y

if(global_save_var){
ggsave2('tl19-07_pir-v-nonpir_mean_TPM_barchart.pdf',
        plot = y,
        dpi = 300,
        width = 15,
        height = 10,
        units = 'cm')
}
```

# Fourier analysis of the expression data.

Used a script written by Chris Illingham and shared by Adam Reid. This is written in C++ so I don't quite understand all of it, but from what I can tell it calculates the phase order for each gene given the data points using the sine/cosine Fourier transform (as opposed to using complex numbers).

```{r different_phase_genes}
phase_df <- read_delim('./Fourier_code/Fourier_data.out',
                       delim = " ",
                       trim_ws = TRUE)
# This definitely isn't reading in correctly past Phase. There's spaces in the column names for 'Normalised input' which is missing stuff up.

# total_tpm_expression(list_genes = list(PCHAS_0100651 = 'PCHAS_0100651',
#                                        PCHAS_0100600 = 'PCHAS_0100600',
#                                        PCHAS_0100700 = 'PCHAS_0100700'))

phase_ordered_df <- dplyr::arrange(phase_df,
                                   Phase)

select_gene_index <- ceiling(
  sapply(
    c(1/nrow(phase_ordered_df), 
      1/4, 
      1/2, 
      3/4, 
      1),
    `*`,
    nrow(phase_ordered_df)
  )
)
#Oddly I think the 1/nrow multiplication gives a double/float (i.e. a decimel) which subsetting then converts to an integer giving zero!

# (phaseiest_genes <- phase_ordered_df[select_gene_index,])
# phaseiest_genes <- phaseiest_genes$ID
# phaseiest_genes_list <- as.list(phaseiest_genes)
# names(phaseiest_genes_list) <- phaseiest_genes
# total_tpm_expression(
#   phaseiest_genes_list
#   )

#Note that the genes at certain phase extremities may have very low expression

#The proportionally top genes of each phase

phaseiest_genes <- list(
  top_phase = slice_max(phase_df,
                        order_by = Phase,
                        n = 100)$ID, #Highest
  upp_quart_phase = slice_min(
    slice_max(phase_df,
              order_by = Phase,
              prop = 0.25),
    order_by = Phase,
    n = 100
  )$ID,
  upp_third_phase = slice_min(
    slice_max(phase_df,
              order_by = Phase,
              prop = 0.33),
    order_by = Phase,
    n = 100
  )$ID,
  mid_phase = slice_min(
    slice_max(phase_df,
              order_by = Phase,
              prop = 0.55),
    order_by = Phase,
    n = 100
  )$ID, #Middle (lowest of the top 50%)
    low_quart_phase = slice_max(
    slice_min(phase_df,
              order_by = Phase,
              prop = 0.25),
    order_by = Phase,
    n = 100
  )$ID,
  min_phase = slice_min(phase_df,
                        order_by = Phase,
                        n = 100)$ID #Lowest
)
total_tpm_expression(phaseiest_genes)
```

Expression profiles of the pir genes with Fourier transforms predicting a frequency over 1Hz (all 2Hz)

```{r pirs_over_1Hz}
two_freq_pirs <- as.list(
  filter(phase_df,
       ID %in% cir_id,
       Max.freq > 1)$ID
  )
names(two_freq_pirs) <- unlist(two_freq_pirs)
total_tpm_expression(list_genes = two_freq_pirs)
```


```{r}
filter(phase_df,
       Max.freq > 1) %>% 
  arrange(desc(Significance))

filter(phase_df,
       Max.freq > 1) %>% 
  group_by(Max.freq) %>% 
  top_n(Significance, 
        n = 3) %>% 
  arrange(desc(Max.freq), 
          desc(Significance))
total_tpm_expression(list_genes = list(
  four_Hz = 'PCHAS_1460200',
  three_Hz = 'PCHAS_1317100',
  two_Hz = 'PCHAS_1411500'
))

phase_df$Max.freq %>% unique

arrange(phase_df, 
        Significance)

filter(phase_df, 
        abs(Phase) < 0.5)
```

# Sessioninfo

```{r}
sessionInfo()
```

